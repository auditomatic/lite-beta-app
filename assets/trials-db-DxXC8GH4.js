var t=Object.defineProperty,e=(e,r,a)=>((e,r,a)=>r in e?t(e,r,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[r]=a)(e,"symbol"!=typeof r?r+"":r,a);import{ah as r,f as a,c as s,ai as o}from"./vendor-l9j4AUWK.js";import{l as i}from"./db-CL8uhZCz.js";import{d as n}from"./index-C0R72Zhc.js";import{g as l}from"./defaultData-DyqJdH2z.js";import{p as c}from"./registry-D04k-NiV.js";import{b as u}from"./designs-db-BelWLWDl.js";import{u as d}from"./settings-db-DC9a7YAn.js";import{l as f}from"./logger.service-_k__GSpu.js";class p{static extractContent(t,e){if(!t)return{success:!1,error:"No response body"};const r=this.getValueAtPath(t,e.contentPath);if(null!=r){if(e.isJSON&&"string"==typeof r)try{const t=JSON.parse(r);return t&&"object"==typeof t&&"answer"in t?{success:!0,content:String(t.answer)}:{success:!0,content:JSON.stringify(t)}}catch{return{success:!0,content:String(r)}}return{success:!0,content:String(r)}}if(e.fallbackPaths)for(const a of e.fallbackPaths){const e=this.getValueAtPath(t,a);if(null!=e)return{success:!0,content:String(e)}}if(e.errorPath){const r=this.getValueAtPath(t,e.errorPath);if(null!=r)return{success:!1,error:String(r)}}return{success:!1,error:`No content found at path '${e.contentPath}' or fallback paths`}}static getValueAtPath(t,e){if(t&&e)try{const r=e.split(".").flatMap(t=>{const e=t.match(/^([^[]+)\[(\d+)\]$/);if(e)return[e[1],parseInt(e[2])];const r=t.match(/^\[(\d+)\]$/);return r?[parseInt(r[1])]:[t]});let a=t;for(const t of r){if(null==a)return;a=a[t]}return a}catch(r){return}}}class h{static detectRefusal(t,e){if(!t||!e||0===e.length)return!1;const r=t.toLowerCase();for(const a of e)if(r.includes(a.toLowerCase()))return!0;return!1}static async getRefusalWords(t){const e=t.designSnapshot,r=[];if(e.refusalWords&&e.refusalWords.length>0&&r.push(...e.refusalWords),e.refusalWordsListRef)try{const t=await n.variableLists.get(e.refusalWordsListRef);t&&t.values&&r.push(...t.values)}catch(a){console.warn("Failed to load refusal words list:",a)}return r}static async processRefusalDetection(t,e){if(!t.result||!t.result.success||!t.result.content)return;const r=await this.getRefusalWords(e);if(0===r.length)return;const a=String(t.result.content),s=this.detectRefusal(a,r);t.result.refused=s,s&&e.designSnapshot.rejectRefusalWords&&(t.result.success=!1,t.result.error="Response contained refusal words")}}class g{constructor(t){e(this,"options"),e(this,"abortController"),this.options={maxRetries:3,retryDelay:5e3,rateLimitDelay:1e3,...t}}async executeAPICall(t,e,r){t.status="running",t.created=new Date,this.options.onProgress?.(t);try{const a=this.options.getApiKey(e.provider),s=this.options.getBaseUrl(e.provider);if(!a&&c.requiresApiKey(e.provider))throw new Error(`No API key configured for provider: ${e.provider}`);const o={id:`${e.provider}:${e.modelId}`,name:e.name,provider:e.provider,model:e.modelId,params:e.parameters,created_at:new Date},i=this.getResponseModeFromConfig(e),n=u.buildAPIRequest(o,t.prompt,a,s,i);t.request={...n,timestamp:new Date};const l=await this.executeWithRetries(n);if(t.response=l,i?.responseTransform){const e=p.extractContent(l.body,i.responseTransform);t.result=e}else t.result={success:!1,error:"No responseTransform configuration found for this response mode"};return r&&t.result&&await h.processRefusalDetection(t,r),t.status="completed",t.completed=new Date,this.options.onProgress?.(t),t}catch(a){return t.status="failed",t.result?t.result.error=a instanceof Error?a.message:String(a):t.result={success:!1,error:a instanceof Error?a.message:String(a)},t.completed=new Date,this.options.onError?.(t,a),t}}async executeWithRetries(t){let e=null;for(let a=0;a<this.options.maxRetries;a++)try{const r=Date.now(),s=await fetch(t.url,{method:t.method,headers:t.headers,body:JSON.stringify(t.body),signal:this.abortController?.signal}),o=Date.now()-r,i=await s.text();let n;try{n=JSON.parse(i)}catch{n=i}const l={status:s.status,headers:Object.fromEntries(s.headers.entries()),body:n,latencyMs:o};if(!s.ok){const t=u.extractErrorMessage(n);if(this.shouldRetry(s.status,a)){e=new Error(`API error (${s.status}): ${t}`),await this.delay(this.getRetryDelay(s.status,a));continue}throw new Error(`API error (${s.status}): ${t}`)}if(u.isErrorResponse(n)){const t=u.extractErrorMessage(n);throw new Error(`Provider error: ${t}`)}return this.options.rateLimitDelay&&this.options.rateLimitDelay>0&&await this.delay(this.options.rateLimitDelay),l}catch(r){if(r instanceof Error&&"AbortError"===r.name)throw new Error("API call execution aborted");if(e=r,a<this.options.maxRetries-1){await this.delay(this.options.retryDelay);continue}}throw e||new Error("Unknown error during API execution")}shouldRetry(t,e){return!(e>=this.options.maxRetries-1)&&(429===t||t>=500)}getRetryDelay(t,e){return 429===t?Math.min(1e3*Math.pow(2,e),6e4):this.options.retryDelay}delay(t){return new Promise(e=>setTimeout(e,t))}abort(){this.abortController?.abort()}getResponseModeFromConfig(t){const e=c.getProvider(t.provider);if(!e?.responseModes)return null;for(const[,r]of Object.entries(e.responseModes)){const e=r.parameters||{};if(Object.keys(e).every(e=>e in t.parameters)&&Object.keys(e).length>0)return r}return e.responseModes.text||Object.values(e.responseModes)[0]}}class m{constructor(t){e(this,"executor"),e(this,"aborted",!1),e(this,"providerConcurrency"),this.executor=new g(t),this.providerConcurrency={};for(const[e,r]of Object.entries(c.getAllProviders()))this.providerConcurrency[e]=t.providerConcurrency?.[e]||r.execution?.defaultConcurrency||4}async executeBatch(t,e){const r=new Map;for(const s of t){const t=e.configurationSnapshots[s.configurationIndex];if(!t){s.status="failed",s.result={success:!1,error:`Configuration not found at index: ${s.configurationIndex}`};continue}const a=t.provider;r.has(a)||r.set(a,[]),r.get(a).push(s)}t.length,r.size;for(const[s,o]of r){this.providerConcurrency[s];o.length}const a=Array.from(r.entries()).map(([t,r])=>this.executeProviderBatch(t,r,e));return(await Promise.all(a)).flat()}async executeProviderBatch(t,e,r){const a=[],s=[...e],o=new Set,i=this.providerConcurrency[t]||4;for(;(s.length>0||o.size>0)&&!this.aborted;){for(;s.length>0&&o.size<i&&!this.aborted;){const t=s.shift(),e=r.configurationSnapshots[t.configurationIndex],i=this.executor.executeAPICall(t,e,r).then(t=>(a.push(t),o.delete(i),t)).catch(e=>(t.status="failed",t.result={success:!1,error:e.message},a.push(t),o.delete(i),t));o.add(i)}o.size>0&&await Promise.race(o)}return a}abort(){this.aborted=!0,this.executor.abort()}}class w{constructor(t){e(this,"batchExecutor"),this.batchExecutor=new m(t)}generateVariableCombinations(t){if(0===t.variableSnapshots.length)return[{variables:{}}];let e=[{variables:{}}];for(const r of t.variableSnapshots){const t=[];for(const a of e)if("simple"===r.category&&r.data.values)for(const e of r.data.values)t.push({variables:{...a.variables,[r.variableName]:e},attributes:a.attributes});else if("attributed"===r.category&&r.data.items)for(const e of r.data.items){const s=a.attributes||{};s[r.variableName]=e.attributes,t.push({variables:{...a.variables,[r.variableName]:e.value},attributes:s})}e=t}return e}generateAPICallsFromTrial(t){const e=[],r=this.generateVariableCombinations(t);return t.configurationSnapshots.forEach((a,s)=>{r.forEach(r=>{let a=t.designSnapshot.promptTemplate;Object.entries(r.variables).forEach(([t,e])=>{const r=`{{${t}}}`;a=a.replace(new RegExp(r,"g"),e)});const o={id:l(),trialId:t.id,configurationIndex:s,variables:r.variables,variableAttributes:r.attributes,prompt:a,request:{url:"",method:"POST",headers:{},body:{},timestamp:new Date},status:"pending",created:new Date};e.push(o)})}),e}async executeTrial(t){const e=this.generateAPICallsFromTrial(t);return await this.batchExecutor.executeBatch(e,t)}abort(){this.batchExecutor.abort()}}const y=r("trials",()=>{const t=a([]),e=a(!1),r=a(null);let p=null,h=new Map;async function g(t,e){try{await n.trials.update(t,e)}catch(r){throw f.error("Failed to update trial",r),new Error("Failed to update trial")}}async function m(t){try{return await n.trials.get(t)}catch(e){return void f.error("Failed to get trial",e)}}function y(t,e,r){if(!r?.tokenEstimate)return null;let a=0;for(const s of t){const t=s.modelSnapshot;if(!t.capabilities?.inputCostPerToken||!t.capabilities?.outputCostPerToken)return null;const o=r.tokenEstimate.avgTokens,i=u.getOutputTokenLimit(t.provider,t.modelId,s.parameters||{});a+=(o*t.capabilities.inputCostPerToken+i*t.capabilities.outputCostPerToken)*e}return a}const b=s(()=>{const e={draft:[],running:[],completed:[],failed:[],cancelled:[]};return t.value.forEach(t=>{e[t.status].push(t)}),e}),v=s(()=>t.value.slice().sort((t,e)=>e.created.getTime()-t.created.getTime()).slice(0,10));return{trials:o(t),isLoading:o(e),error:o(r),trialsByStatus:b,recentTrials:v,initialize:async function(){if(!p){e.value=!0,r.value=null;try{p=i(()=>n.trials.orderBy("created").reverse().toArray()).subscribe({next:r=>{t.value=r,e.value=!1},error:t=>{f.error("Trials store subscription error",t),r.value="Failed to load trials",e.value=!1}})}catch(a){f.error("Failed to initialize trials store",a),r.value="Failed to initialize trials",e.value=!1}}},createTrial:async function(t){const e=l(),r=new Date;try{const a=await n.designs.get(t.designId);if(!a)throw new Error("Design not found");const s=[];if(a.variableBindings)for(const[t,e]of Object.entries(a.variableBindings))if("list"===e.type&&e.listId){const a=await n.variableLists.get(e.listId);if(!a)throw new Error(`Variable list not found for variable ${t}: ${e.listId}`);s.push({originalListId:a.id,originalListName:a.name,variableName:t,category:a.category,data:{values:a.values,attributeKeys:a.attributeKeys,items:a.items,itemCount:a.itemCount},snapshotDate:r})}else"direct"===e.type&&e.values&&s.push({originalListId:`direct-${t}`,originalListName:`Direct values for ${t}`,variableName:t,category:"simple",data:{values:[...e.values],itemCount:e.values.length},snapshotDate:r});const o=[];for(const e of t.configurations){const t=c.getProvider(e.provider);if(!t)throw new Error(`Provider not found: ${e.provider}`);const r=await n.models.get(`${e.provider}:${e.modelId}`);if(!r)throw new Error(`Model not found: ${e.provider}:${e.modelId}`);o.push({name:e.name,provider:e.provider,modelId:e.modelId,parameters:{...e.parameters},providerSnapshot:JSON.parse(JSON.stringify(t)),modelSnapshot:JSON.parse(JSON.stringify(r))})}const i=function(t){return 0===t.length?0:t.reduce((t,e)=>t*e.data.itemCount,1)}(s),l={id:e,name:t.name,designSnapshot:{originalId:a.id,originalName:a.name,promptTemplate:a.promptTemplate,variableBindings:JSON.parse(JSON.stringify(a.variableBindings)),outputType:a.outputType,extractPattern:a.extractPattern,refusalWords:a.refusalWords?[...a.refusalWords]:void 0,refusalWordsListRef:a.refusalWordsListRef,refusalWordsSource:a.refusalWordsSource,rejectRefusalWords:a.rejectRefusalWords,snapshotDate:r},configurationSnapshots:o,variableSnapshots:s,status:"draft",progress:{total:i*o.length,completed:0,networkErrors:0},totalCombinations:i,estimatedCost:y(o,i,a)||0,created:r};return await n.trials.add(l),e}catch(a){throw f.error("Failed to create trial",a),new Error(`Failed to create trial: ${a instanceof Error?a.message:"Unknown error"}`)}},updateTrial:g,duplicateTrial:async function(t){try{const e=await n.trials.get(t);if(!e)throw new Error("Trial not found");const r=l(),a={...e,id:r,name:`${e.name} (Copy)`,status:"pending",progress:{total:e.progress.total,completed:0,networkErrors:0},created:new Date};return await n.trials.add(a),r}catch(e){throw f.error("Failed to duplicate trial",e),new Error(`Failed to duplicate trial: ${e instanceof Error?e.message:"Unknown error"}`)}},deleteTrial:async function(t){try{await n.transaction("rw",[n.trials,n.apiCalls],async()=>{await n.apiCalls.where("trialId").equals(t).delete(),await n.trials.delete(t)})}catch(e){throw f.error("Failed to delete trial",e),new Error("Failed to delete trial")}},getTrial:m,executeTrial:async function(t){const e=await m(t);if(!e)throw new Error(`Trial not found: ${t}`);const r=d(),a=new w({getApiKey:t=>r.getApiKey(t),getBaseUrl:t=>r.getBaseUrl(t),providerConcurrency:(await n.settings.get("main"))?.providerConcurrency,onProgress:async e=>{try{if(await n.apiCalls.put(e),"completed"===e.status||"failed"===e.status){const e=await n.trials.get(t);if(e){const r=await n.apiCalls.where("trialId").equals(t).toArray(),a=r.filter(t=>"completed"===t.status||"failed"===t.status).length;e.progress={total:e.configurationSnapshots.length*e.totalCombinations,completed:a,networkErrors:r.filter(t=>"failed"===t.status).length},await n.trials.put(e)}}}catch(r){f.warn("Progress update failed:",{error:r})}},onError:async(t,e)=>{f.error("API call failed",e),await n.apiCalls.put(t)}});try{h.set(t,a),await g(t,{status:"running"});const r=await n.apiCalls.where("trialId").equals(t).toArray(),s=a.generateAPICallsFromTrial(e),o=new Set(r.filter(t=>"completed"===t.status||"failed"===t.status).map(t=>`${t.configurationIndex}-${JSON.stringify(t.variables)}`)),i=s.filter(t=>!o.has(`${t.configurationIndex}-${JSON.stringify(t.variables)}`));f.info(`Resuming trial: ${r.length} existing, ${i.length} pending`);const l=i.length>0?await a.batchExecutor.executeBatch(i,e):[];l.length>0&&await n.apiCalls.bulkPut(l);const c=await n.trials.get(t);if("running"===c?.status){const r=e.configurationSnapshots.length*e.totalCombinations,a=(await n.apiCalls.where("trialId").equals(t).toArray()).filter(t=>"completed"===t.status||"failed"===t.status).length,s=a===r;f.debug(`Trial completion check: ${a}/${r} calls complete`),await g(t,{status:s?"completed":"paused"})}else f.debug(`Trial status is ${c?.status}, not updating from execution`)}catch(s){throw f.error("Trial execution failed",s),await g(t,{status:"failed"}),s}finally{h.delete(t)}},pauseTrial:async function(t){const e=h.get(t);e&&(e.abort(),h.delete(t)),await g(t,{status:"paused"})},cancelTrial:async function(t){const e=h.get(t);e&&(e.abort(),h.delete(t)),await g(t,{status:"cancelled"})},destroy:function(){p&&(p.unsubscribe(),p=null)}}});export{w as T,y as u};
