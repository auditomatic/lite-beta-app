var e=Object.defineProperty,t=(t,r,a)=>((t,r,a)=>r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[r]=a)(t,"symbol"!=typeof r?r+"":r,a);import{l as r,a9 as a,g as i}from"./index-C6frMIbt.js";import{v as n}from"./variable.service-_lbnscns.js";const s=class e{calculateTotalPermutations(e){const t=Object.values(e).filter(e=>e>0);return 0===t.length?0:t.reduce((e,t)=>e*t,1)}getPermutationInfo(t){const r=this.calculateTotalPermutations(t);let a,i;return a=r>999999?`${(r/1e6).toFixed(1)}M`:r>9999?`${(r/1e3).toFixed(0)}k`:r.toLocaleString(),r>e.VERY_LARGE_THRESHOLD?i="Very large trial - may take hours and significant API costs":r>e.LARGE_THRESHOLD&&(i="Large trial - consider sampling or filtering"),{total:r,isLarge:r>e.LARGE_THRESHOLD,formatted:a,warning:i}}*generatePermutations(e,t=1/0){const r=Object.keys(e),a=r.map(t=>e[t]);if(0===r.length)return;let i=0;const n=function*(e,s){if(i>=t)return;if(e===r.length)return yield{...s},void i++;const o=r[e],l=a[e];for(const r of l){if(i>=t)return;s[o]=r,yield*n(e+1,s)}};yield*n(0,{})}getSamplePermutations(e,t=5){const r=[],a=this.generatePermutations(e,t);for(const i of a)r.push(i);return r}estimateTrialMetrics(e,t,r=2e3,a=.01){const i=e*t,n=i*r*.7;return{totalCalls:i,estimatedTimeMinutes:Math.ceil(n/6e4),estimatedCostUSD:i*a}}shouldSample(t,r=e.LARGE_THRESHOLD){const a=this.calculateTotalPermutations(t);if(a<=r)return{shouldSample:!1};let i;return i=a>1e6?1e3:a>1e5?5e3:Math.min(1e4,Math.floor(.1*a)),{shouldSample:!0,recommendedSampleSize:i}}*generateStratifiedSample(e,t){const r=this.calculateTotalPermutations(Object.fromEntries(Object.entries(e).map(([e,t])=>[e,t.length])));if(r<=t)return void(yield*this.generatePermutations(e));const a=Math.floor(r/t);let i=0,n=0;for(const s of this.generatePermutations(e))if(i%a===0&&n<t&&(yield s,n++),i++,n>=t)break}};t(s,"LARGE_THRESHOLD",1e4),t(s,"VERY_LARGE_THRESHOLD",1e5);const o=new s;function l(e){return new Worker(""+new URL("token-calculation.worker-_TmsjB_5.js",import.meta.url).href,{name:e?.name})}const c=new class{constructor(){t(this,"worker",null),t(this,"pendingRequests",new Map),t(this,"isWorkerSupported","undefined"!=typeof Worker),t(this,"workerLoadError",null),t(this,"isInitializing",!1),t(this,"isInitialized",!1)}async initializeWorker(){if(!this.isInitialized&&!this.isInitializing&&this.isWorkerSupported){this.isInitializing=!0;try{const e=/^((?!chrome|android).)*safari/i.test(navigator.userAgent),t=navigator.userAgent.match(/Version\/(\d+)/),a=t?parseInt(t[1]):0;if(e&&a>0&&a<17)throw new Error("Safari 16 or older detected - worker not supported");this.worker=new l,this.worker.addEventListener("message",this.handleWorkerMessage.bind(this)),this.worker.addEventListener("error",this.handleWorkerError.bind(this)),await this.primeWorker(),this.isInitialized=!0,r.info("Persistent token calculation worker initialized and primed")}catch(e){r.error("Failed to initialize token calculation worker",e),this.workerLoadError=e,this.isWorkerSupported=!1,this.worker=null}finally{this.isInitializing=!1}}}async primeWorker(){if(!this.worker)return;const e=`prime-${Date.now()}`;return new Promise((t,r)=>{const a=setTimeout(()=>{this.pendingRequests.delete(e),r(new Error("Worker priming timeout"))},3e4);this.pendingRequests.set(e,{resolve:()=>{clearTimeout(a),t()},reject:e=>{clearTimeout(a),r(e)}}),this.worker.postMessage({id:e,method:"accurate",design:{id:"prime",promptTemplate:"test",variableBindings:{},executionMode:"cartesian"}})})}async ensureWorkerReady(){if(!this.isWorkerSupported)throw new Error("Workers not supported in this environment");if(this.workerLoadError)throw this.workerLoadError;for(this.isInitialized||this.isInitializing||await this.initializeWorker();this.isInitializing;)await new Promise(e=>setTimeout(e,50));if(!this.worker||!this.isInitialized)throw new Error("Worker failed to initialize")}handleWorkerMessage(e){const t=e.data,a=this.pendingRequests.get(t.id);if(a)switch(t.type){case"progress":a.onProgress?.(t);break;case"result":a.resolve(t.result),this.pendingRequests.delete(t.id);break;case"error":a.reject(new Error(t.error.message)),this.pendingRequests.delete(t.id)}else r.warn("Received message for unknown request",{messageId:t.id})}handleWorkerError(e){r.error("Worker error",e),this.pendingRequests.forEach(e=>{e.reject(new Error("Worker crashed"))}),this.pendingRequests.clear(),this.worker?.terminate(),this.worker=null,setTimeout(()=>{this.isWorkerSupported&&this.initializeWorker()},1e3)}async prepareDesignData(e){const t=JSON.parse(JSON.stringify(e)),a={};for(const[s,o]of Object.entries(t.variableBindings||{}))if("list"===o.type&&o.listId)try{const e=await n.getListValues(o.listId);a[s]={type:"direct",values:[...e]}}catch(i){r.warn("Failed to resolve list values for variable",{error:i,varName:s}),a[s]={type:"direct",values:[]}}else a[s]=JSON.parse(JSON.stringify(o));return{id:t.id,promptTemplate:t.promptTemplate,variableBindings:a,executionMode:t.executionMode}}async calculateApproximate(e){try{await this.ensureWorkerReady()}catch(a){throw new Error("Worker not available for approximate calculation")}const t=`${e.id}-${Date.now()}-${Math.random()}`,r=await this.prepareDesignData(e);return new Promise((e,a)=>{this.pendingRequests.set(t,{resolve:e,reject:a});const i={id:t,method:"approximate",design:r};this.worker.postMessage(i),setTimeout(()=>{this.pendingRequests.has(t)&&(this.pendingRequests.delete(t),a(new Error("Worker timeout")))},5e3)})}async calculateAccurate(e,t){try{await this.ensureWorkerReady()}catch(n){throw r.warn("Worker not available for accurate calculation",{error:n}),new Error("Worker not available for accurate calculation")}const a=`${e.id}-${Date.now()}-${Math.random()}`,i=await this.prepareDesignData(e);return new Promise((e,r)=>{this.pendingRequests.set(a,{resolve:e,reject:r,onProgress:t});const n={id:a,method:"accurate",design:i};this.worker.postMessage(n),setTimeout(()=>{this.pendingRequests.has(a)&&(this.pendingRequests.delete(a),r(new Error("Worker timeout - calculation taking too long")))},1e4)})}isWorkerAvailable(){return this.isWorkerSupported&&null===this.workerLoadError}terminate(){this.worker&&(this.pendingRequests.forEach(e=>{e.reject(new Error("Worker terminated"))}),this.pendingRequests.clear(),this.worker.terminate(),this.worker=null,this.isInitialized=!1,this.isInitializing=!1,r.info("Persistent token calculation worker terminated"))}};const u=new class{constructor(){t(this,"tokenCountCache",new Map)}async calculateDesignTokens(e){try{const a=this.getDesignCacheKey(e),i=this.tokenCountCache.get(a);if(i&&i.calculated&&Date.now()-i.calculated.getTime()<36e5)return i;if(r.info("Calculating tokens for design",{designName:e.name}),c.isWorkerAvailable())try{const t=new Promise((e,t)=>{setTimeout(()=>t(new Error("Token calculation timeout")),5e3)}),i=await Promise.race([c.calculateApproximate(e),t]);return r.info("Token calculation complete (worker)",{designName:e.name}),this.tokenCountCache.set(a,i),i}catch(t){r.warn("Worker calculation failed or timed out, falling back to simple approximation",{error:t})}if(r.info("Calculating tokens on main thread with variable-aware approximation"),"aligned"===e.executionMode)return this.calculateAlignedDesignTokens(e);const n=e.promptTemplate.replace(/\{\{[^}]+\}\}/g,""),s=await this.countTokens(n),o=await this.getVariableValues(e),l={};for(const[e,t]of Object.entries(o)){if(0===t.length){l[e]={min:0,max:0,avg:0};continue}const r=await Promise.all(t.map(e=>this.countTokens(e)));l[e]={min:Math.min(...r),max:Math.max(...r),avg:Math.round(r.reduce((e,t)=>e+t,0)/r.length)}}let u=s,d=s,h=s;for(const e of Object.values(l))u+=e.min,d+=e.max,h+=e.avg;const m={minTokens:u,maxTokens:d,avgTokens:h,sampleSize:Object.values(o).reduce((e,t)=>e+t.length,0),calculated:new Date,isAccurate:!1};return r.info("Token calculation complete (main thread)",{designName:e.name}),this.tokenCountCache.set(a,m),m}catch(a){return r.error("Failed to calculate design tokens",a),{minTokens:0,maxTokens:0,avgTokens:0,sampleSize:0,calculated:new Date}}}async calculateDesignTokensAccurate(e,t){try{const i=this.getDesignCacheKey(e)+":accurate",n=this.tokenCountCache.get(i);if(n&&n.calculated&&n.isAccurate&&Date.now()-n.calculated.getTime()<36e5)return n;if(c.isWorkerAvailable())try{const a=new Promise((e,t)=>{setTimeout(()=>t(new Error("Accurate token calculation timeout")),1e4)}),n=await Promise.race([c.calculateAccurate(e,t?e=>{t({stage:e.stage,current:e.current,total:e.total,message:e.message})}:void 0),a]);return r.info("Accurate token calculation complete (worker)",{designName:e.name}),this.tokenCountCache.set(i,n),n}catch(a){return r.warn("Worker accurate calculation failed or timed out, falling back to approximate",{error:a}),this.calculateDesignTokens(e)}return r.warn("Worker not available for accurate calculation, using approximate"),this.calculateDesignTokens(e)}catch(i){return r.error("Failed to calculate accurate tokens",i),this.calculateDesignTokens(e)}}async calculateCostEstimate(e,t,r){const a=await this.calculateDesignTokens(e),i=this.getOutputTokenLimit(t.provider,t.modelId,r),n=t.capabilities?.inputCostPerToken||0,s=t.capabilities?.outputCostPerToken||0,l={min:a.minTokens*n+i*s,max:a.maxTokens*n+i*s,avg:a.avgTokens*n+i*s},c=await this.getVariableCounts(e),u=o.calculateTotalPermutations(c);return{inputTokens:a,outputTokens:i,costPerCall:l,totalCost:{min:l.min*u,max:l.max*u,avg:l.avg*u},environmentalCosts:undefined}}async calculateCostEstimateFromContext(e,t,r,a){const i={minTokens:Math.floor(.8*t),maxTokens:Math.ceil(1.2*t),avgTokens:t,sampleSize:1,calculated:new Date,isAccurate:!1},n=this.getOutputTokenLimit(r.provider,r.modelId,a),s=r.capabilities?.inputCostPerToken||0,o=r.capabilities?.outputCostPerToken||0,l={min:i.minTokens*s+n*o,max:i.maxTokens*s+n*o,avg:i.avgTokens*s+n*o};return{inputTokens:i,outputTokens:n,costPerCall:l,totalCost:{min:l.min*e,max:l.max*e,avg:l.avg*e},environmentalCosts:undefined}}getOutputTokenLimit(e,t,r){return a.getOutputTokenLimit(e,t,r)}async countTokens(e){if(!e||0===e.length)return 0;const t=/[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(e),r=/[\u0600-\u06ff\u0750-\u077f]/.test(e);if(t)return Math.ceil(.6*e.length);if(r)return Math.ceil(e.length/5);{const t=e.split(/\s+/).filter(e=>e.length>0),r=t.length>0?e.replace(/\s+/g,"").length/t.length:5;return r<4?Math.ceil(e.length/3.5):r>7?Math.ceil(e.length/4.5):Math.ceil(e.length/4)}}async getVariableCounts(e){const t={};for(const[r,a]of Object.entries(e.variableBindings||{}))if("direct"===a.type&&a.values)t[r]=a.values.length;else if("list"===a.type&&a.listId){const e=await n.getListValues(a.listId);t[r]=e.length}return t}async getVariableValues(e){const t={};try{for(const[i,s]of Object.entries(e.variableBindings||{}))if("direct"===s.type&&s.values)t[i]=s.values;else if("list"===s.type&&s.listId)try{const e=await n.getListValues(s.listId);t[i]=e}catch(a){r.warn("Failed to get list values for variable",{error:a,varName:i}),t[i]=[]}}catch(a){r.error("Error getting variable values",a)}return t}getDesignCacheKey(e){const t=JSON.stringify(e.variableBindings);return`${e.id}:${e.promptTemplate}:${t}`}async calculateEnvironmentalCostEstimate(e,t,r){return{carbon:0,water:0,energy:0,confidence:"none",source:"no-data"}}async calculateAlignedDesignTokens(e){try{const t=e.variableBindings?.__tabular__;if(!t||"list"!==t.type||!t.listId)throw new Error("Aligned design missing tabular data binding");const r=await i.variableLists.get(t.listId);if(!r||!r.tabularData)throw new Error("Tabular variable list not found or missing data");const{columns:a,rows:n}=r.tabularData;if(0===n.length)return{minTokens:0,maxTokens:0,avgTokens:0,sampleSize:0,calculated:new Date};const s=Math.min(n.length,10),o=n.slice(0,s),l=[];for(const i of o){let t=e.promptTemplate;for(const e of a){const r=String(i[e]||""),a=`{{${e}}}`;t=t.replace(new RegExp(a.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"g"),r)}const r=await this.countTokens(t);l.push(r)}return{minTokens:Math.min(...l),maxTokens:Math.max(...l),avgTokens:Math.round(l.reduce((e,t)=>e+t,0)/l.length),sampleSize:n.length,calculated:new Date,isAccurate:!1}}catch(t){return r.error("Failed to calculate aligned design tokens",t),{minTokens:0,maxTokens:0,avgTokens:0,sampleSize:0,calculated:new Date}}}clearCache(){this.tokenCountCache.clear()}};export{o as p,u as t};
