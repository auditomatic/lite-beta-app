var re=Object.defineProperty;var ae=(l,e,t)=>e in l?re(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var I=(l,e,t)=>ae(l,typeof e!="symbol"?e+"":e,t);import{b as z,I as H,Y as se,Z as ie,$ as ne,a0 as W,a as r,s as L,c as A,n as U,o as q,a1 as oe,l as j,d as o,a2 as M,h as X,a3 as Y,g as $,a4 as le,a5 as F,a6 as D,a7 as ue,a8 as ce,p as k,r as N}from"./index-BHXEDjmJ.js";var de={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M516 673c0 4.4 3.4 8 7.5 8h185c4.1 0 7.5-3.6 7.5-8v-48c0-4.4-3.4-8-7.5-8h-185c-4.1 0-7.5 3.6-7.5 8v48zm-194.9 6.1l192-161c3.8-3.2 3.8-9.1 0-12.3l-192-160.9A7.95 7.95 0 00308 351v62.7c0 2.4 1 4.6 2.9 6.1L420.7 512l-109.8 92.2a8.1 8.1 0 00-2.9 6.1V673c0 6.8 7.9 10.5 13.1 6.1zM880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"}}]},name:"code",theme:"outlined"};function G(l){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?Object(arguments[e]):{},a=Object.keys(t);typeof Object.getOwnPropertySymbols=="function"&&(a=a.concat(Object.getOwnPropertySymbols(t).filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable}))),a.forEach(function(s){pe(l,s,t[s])})}return l}function pe(l,e,t){return e in l?Object.defineProperty(l,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):l[e]=t,l}var Q=function(e,t){var a=G({},e,t.attrs);return z(H,G({},a,{icon:de}),null)};Q.displayName="CodeOutlined";Q.inheritAttrs=!1;var fe={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM514.1 580.1l-61.8-102.4c-2.2-3.6-6.1-5.8-10.3-5.8h-38.4c-2.3 0-4.5.6-6.4 1.9-5.6 3.5-7.3 10.9-3.7 16.6l82.3 130.4-83.4 132.8a12.04 12.04 0 0010.2 18.4h34.5c4.2 0 8-2.2 10.2-5.7L510 664.8l62.3 101.4c2.2 3.6 6.1 5.7 10.2 5.7H620c2.3 0 4.5-.7 6.5-1.9 5.6-3.6 7.2-11 3.6-16.6l-84-130.4 85.3-132.5a12.04 12.04 0 00-10.1-18.5h-35.7c-4.2 0-8.1 2.2-10.3 5.8l-61.2 102.3z"}}]},name:"file-excel",theme:"outlined"};function B(l){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?Object(arguments[e]):{},a=Object.keys(t);typeof Object.getOwnPropertySymbols=="function"&&(a=a.concat(Object.getOwnPropertySymbols(t).filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable}))),a.forEach(function(s){ge(l,s,t[s])})}return l}function ge(l,e,t){return e in l?Object.defineProperty(l,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):l[e]=t,l}var Z=function(e,t){var a=B({},e,t.attrs);return z(H,B({},a,{icon:fe}),null)};Z.displayName="FileExcelOutlined";Z.inheritAttrs=!1;var J=function(l){se(e,l);function e(t,a,s){t===void 0&&(t=1/0),a===void 0&&(a=1/0),s===void 0&&(s=ie);var i=l.call(this)||this;return i._bufferSize=t,i._windowTime=a,i._timestampProvider=s,i._buffer=[],i._infiniteTimeWindow=!0,i._infiniteTimeWindow=a===1/0,i._bufferSize=Math.max(1,t),i._windowTime=Math.max(1,a),i}return e.prototype.next=function(t){var a=this,s=a.isStopped,i=a._buffer,n=a._infiniteTimeWindow,h=a._timestampProvider,g=a._windowTime;s||(i.push(t),!n&&i.push(h.now()+g)),this._trimBuffer(),l.prototype.next.call(this,t)},e.prototype._subscribe=function(t){this._throwIfClosed(),this._trimBuffer();for(var a=this._innerSubscribe(t),s=this,i=s._infiniteTimeWindow,n=s._buffer,h=n.slice(),g=0;g<h.length&&!t.closed;g+=i?1:2)t.next(h[g]);return this._checkFinalizedStatuses(t),a},e.prototype._trimBuffer=function(){var t=this,a=t._bufferSize,s=t._timestampProvider,i=t._buffer,n=t._infiniteTimeWindow,h=(n?1:2)*a;if(a<1/0&&h<i.length&&i.splice(0,i.length-h),!n){for(var g=s.now(),p=0,d=1;d<i.length&&i[d]<=g;d+=2)p=d;p&&i.splice(0,p+1)}},e}(ne);function he(l,e,t){var a,s,i,n,h=!1;return l&&typeof l=="object"?(a=l.bufferSize,n=a===void 0?1/0:a,s=l.windowTime,e=s===void 0?1/0:s,i=l.refCount,h=i===void 0?!1:i,t=l.scheduler):n=l??1/0,W({connector:function(){return new J(n,e,t)},resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:h})}function Ae(){const l=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials() composable ENTRY at ${l}`);const e=L([]),t=L(!0),a=L(null);let s=null;const i=A(()=>e.value),n=()=>{const T=performance.now();r.info(`V4_TRIAL_SWITCH: setupLiveQuery() ENTRY at ${T}`),s&&(s.unsubscribe(),s=null);const c=j(async()=>{try{return(await o.trials.orderBy("created").reverse().toArray()).filter(v=>!M(v)).map(v=>Object.freeze({...v,created:v.created instanceof Date?v.created:new Date(v.created),started:v.started?v.started instanceof Date?v.started:new Date(v.started):void 0,completed:v.completed?v.completed instanceof Date?v.completed:new Date(v.completed):void 0}))}catch(u){throw console.error("V4_TRIALS: Failed to load trials:",u),u}});s=X(c).subscribe({next:u=>{e.value=u,t.value=!1,a.value=null,r.debug(`V4_TRIALS_DB: Loaded ${u.length} trials from database`)},error:u=>{console.error("V4_TRIALS: Query error:",u),a.value=u instanceof Error?u:new Error("Failed to load trials"),t.value=!1}})},h=A(()=>i.value.filter(T=>T.status==="running")),g=A(()=>i.value.filter(T=>T.status==="draft")),p=A(()=>i.value.filter(T=>T.status==="completed")),d=A(()=>i.value.filter(T=>T.status==="paused")),m=A(()=>i.value.filter(T=>T.status==="failed")),f=A(()=>i.value.length),b=A(()=>{const T={total:i.value.length,byStatus:{draft:0,pending:0,running:0,paused:0,completed:0,cancelled:0,failed:0},totalApiCalls:0,completedApiCalls:0,failedApiCalls:0,averageCompletionRate:0};for(const c of i.value)T.byStatus[c.status]++,c.progress&&(T.totalApiCalls+=c.progress.total,T.completedApiCalls+=c.progress.completed,T.failedApiCalls+=c.progress.failed);return T.totalApiCalls>0&&(T.averageCompletionRate=T.completedApiCalls/T.totalApiCalls*100),T}),R=async()=>{t.value=!0,a.value=null;try{const u=(await o.trials.orderBy("created").reverse().toArray()).filter(_=>!M(_)).map(_=>Object.freeze({..._,created:_.created instanceof Date?_.created:new Date(_.created),started:_.started?_.started instanceof Date?_.started:new Date(_.started):void 0,completed:_.completed?_.completed instanceof Date?_.completed:new Date(_.completed):void 0}));e.value=u,t.value=!1,r.debug(`V4_TRIALS: Manual refresh loaded ${u.length} trials`)}catch(T){console.error("V4_TRIALS: Refresh failed:",T),a.value=T instanceof Error?T:new Error("Failed to refresh trials"),t.value=!1}};return U(()=>{const T=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials onMounted() ENTRY at ${T}`),r.info("V4_TRIALS: Mounting trials query composable");const c=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials calling setupLiveQuery() at ${(c-T).toFixed(1)}ms`),n();const u=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials setupLiveQuery() completed in ${(u-c).toFixed(1)}ms`)}),q(()=>{r.debug("V4_TRIALS: Unmounting trials query composable"),s&&(s.unsubscribe(),s=null)}),{trials:i,loading:t,error:a,runningTrials:h,draftTrials:g,completedTrials:p,pausedTrials:d,failedTrials:m,totalTrials:f,statistics:b,refresh:R}}function Oe(l){const e=L(null),t=L(!0),a=L(null);let s=null,i=null;const n=A(()=>(typeof l=="object"&&l!==null?l.value:l)?e.value:null),h=p=>{const d=performance.now();if(r.debug(`V4_TRIAL_SWITCH: Single trial query setup for ${p}`),s&&(s.unsubscribe(),s=null),!p){e.value=null,t.value=!1,r.debug("V4_TRIAL_SWITCH: Single trial query cleared (no ID)");return}const m=j(async()=>{const f=performance.now();r.debug(`V4_TRIAL_SWITCH: Single trial DB query starting at ${(f-d).toFixed(1)}ms`);const b=await o.trials.get(p),R=performance.now();return r.debug(`V4_TRIAL_SWITCH: Single trial DB query completed in ${(R-f).toFixed(1)}ms`),b?Object.freeze({...b,created:b.created instanceof Date?b.created:new Date(b.created),started:b.started?b.started instanceof Date?b.started:new Date(b.started):void 0,completed:b.completed?b.completed instanceof Date?b.completed:new Date(b.completed):void 0}):null});s=X(m).subscribe({next:f=>{const b=performance.now();e.value=f,t.value=!1,a.value=null,f&&r.debug(`V4_TRIAL_SWITCH: Trial ${f.id} loaded from database in ${(b-d).toFixed(1)}ms`)},error:f=>{console.error("V4_TRIALS: Single trial query error:",f),a.value=f instanceof Error?f:new Error("Failed to load trial"),t.value=!1}})},g=async()=>{const p=typeof l=="object"&&l!==null?l.value:l;if(!p){e.value=null,t.value=!1;return}t.value=!0,a.value=null;try{const d=await o.trials.get(p);d?e.value=Object.freeze({...d,created:d.created instanceof Date?d.created:new Date(d.created),started:d.started?d.started instanceof Date?d.started:new Date(d.started):void 0,completed:d.completed?d.completed instanceof Date?d.completed:new Date(d.completed):void 0}):e.value=null,t.value=!1}catch(d){console.error("V4_TRIALS: Refresh single trial failed:",d),a.value=d instanceof Error?d:new Error("Failed to refresh trial"),t.value=!1}};return typeof l=="object"&&l!==null?U(()=>{r.debug("V4_TRIALS: Mounting single trial query with reactive ID"),i=oe(()=>{const p=l.value;r.debug("V4_TRIALS: Trial ID changed to:",p),h(p)})}):U(()=>{r.debug("V4_TRIALS: Mounting single trial query for static ID:",l),h(l)}),q(()=>{r.debug("V4_TRIALS: Unmounting single trial query"),s&&(s.unsubscribe(),s=null),i&&(i(),i=null)}),{trial:n,loading:t,error:a,refresh:g}}class me{constructor(){I(this,"state",Y({status:"idle",trialId:null,orchestratorType:null,startedAt:null,pausedAt:null,completedAt:null,tabId:null}));I(this,"currentState",A(()=>({...this.state})));I(this,"status",A(()=>this.state.status));I(this,"trialId",A(()=>this.state.trialId));I(this,"orchestratorType",A(()=>this.state.orchestratorType));I(this,"isExecuting",A(()=>["starting","running","pausing"].includes(this.state.status)));I(this,"isPaused",A(()=>this.state.status==="paused"));I(this,"isIdle",A(()=>this.state.status==="idle"))}async hydrate(){r.debug("STATE_MACHINE: Hydrating state from database...");const e=await o.trials.where("status").equals("running").toArray();if(e.length>0){r.debug(`STATE_MACHINE: Found ${e.length} running trials, marking as paused (page refreshed)`);for(const t of e)await o.trials.update(t.id,{status:"paused"}),r.debug(`STATE_MACHINE: Paused trial ${t.id} (was running, page refreshed)`)}r.debug("STATE_MACHINE: State machine starting idle - use resume to continue paused trials")}async startExecution(e,t,a){if(r.debug(`STATE_MACHINE: Starting execution - trial=${e}, orchestrator=${t}, tab=${a}`),this.state.status!=="idle"&&this.state.status!=="paused")return{ok:!1,error:new Error(`Cannot start: current status is ${this.state.status}`)};try{return this.state.status="starting",this.state.trialId=e,this.state.orchestratorType=t,this.state.tabId=a,this.state.startedAt=new Date,this.state.pausedAt=null,this.state.completedAt=null,await o.trials.update(e,{status:"running",started:this.state.startedAt}),this.state.status="running",r.debug(`STATE_MACHINE: Successfully started execution for trial ${e}`),{ok:!0,value:void 0}}catch(s){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,{ok:!1,error:s instanceof Error?s:new Error("Failed to start execution")}}}async pauseExecution(){if(r.debug(`STATE_MACHINE: Pausing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot pause: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot pause: no active trial")};try{return this.state.status="pausing",this.state.pausedAt=new Date,await o.trials.update(this.state.trialId,{status:"paused"}),this.state.status="paused",r.debug(`STATE_MACHINE: Successfully paused execution for trial ${this.state.trialId}`),{ok:!0,value:void 0}}catch(e){return this.state.status="running",this.state.pausedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to pause execution")}}}async resumeExecution(e,t){if(r.debug(`STATE_MACHINE: Resuming trial ${e} - current status=${this.state.status}, tab=${t}`),!["idle","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot resume: current status is ${this.state.status}`)};try{const a=await o.trials.get(e);if(!a)return{ok:!1,error:new Error(`Trial ${e} not found`)};if(a.status!=="paused")return{ok:!1,error:new Error(`Cannot resume: trial status is ${a.status}, expected paused`)};const s=a.type==="playground"?"streaming":"regular";return this.state.status="running",this.state.trialId=e,this.state.orchestratorType=s,this.state.tabId=t,this.state.startedAt=a.started||new Date,this.state.pausedAt=null,this.state.completedAt=null,await o.trials.update(e,{status:"running"}),r.debug(`STATE_MACHINE: Successfully resumed execution for trial ${e}`),{ok:!0,value:void 0}}catch(a){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,{ok:!1,error:a instanceof Error?a:new Error("Failed to resume execution")}}}async cancelExecution(){if(r.debug(`STATE_MACHINE: Cancelling execution - current status=${this.state.status}`),!["running","paused","starting"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot cancel: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot cancel: no active trial")};try{const e=this.state.trialId;return this.state.status="cancelling",this.state.completedAt=new Date,await o.trials.update(e,{status:"cancelled",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.debug(`STATE_MACHINE: Successfully cancelled execution for trial ${e}`),{ok:!0,value:void 0}}catch(e){return this.state.status=this.state.pausedAt?"paused":"running",this.state.completedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to cancel execution")}}}async completeExecution(){if(r.debug(`STATE_MACHINE: Completing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot complete: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot complete: no active trial")};try{const e=this.state.trialId;return this.state.status="completed",this.state.completedAt=new Date,await o.trials.update(e,{status:"completed",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.debug(`STATE_MACHINE: Successfully completed execution for trial ${e}`),{ok:!0,value:void 0}}catch(e){return this.state.status="running",this.state.completedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to complete execution")}}}canStart(){return this.state.status==="idle"||this.state.status==="paused"}canPause(){return this.state.status==="running"}canResume(){return this.state.status==="paused"&&this.state.orchestratorType!==null}canCancel(){return["running","paused","starting"].includes(this.state.status)}isOwnedByTab(e){return this.state.tabId===e}}const E=new me;class be{constructor(){I(this,"state",Y({tabId:$("tab"),role:"observer",isInitialized:!1,lastHeartbeat:new Date}));I(this,"broadcastChannel",null);I(this,"lockReleaseFunction",null);I(this,"heartbeatInterval",null);I(this,"tabId",A(()=>this.state.tabId));I(this,"role",A(()=>this.state.role));I(this,"isLeader",A(()=>this.state.role==="leader"));I(this,"isObserver",A(()=>this.state.role==="observer"));I(this,"isInitialized",A(()=>this.state.isInitialized))}async initialize(){if(this.state.isInitialized){r.debug(`COORDINATION: Tab ${this.state.tabId} already initialized as ${this.state.role}`);return}r.debug(`COORDINATION: Initializing tab ${this.state.tabId}`);try{this.broadcastChannel=new BroadcastChannel("auditomatic-coordination"),this.broadcastChannel.onmessage=e=>{this.handleCoordinationMessage(e.data)},await this.attemptLeadershipAcquisition(),this.startHeartbeat(),this.state.isInitialized=!0,r.debug(`COORDINATION: Tab ${this.state.tabId} initialized as ${this.state.role}`)}catch(e){throw console.error(`COORDINATION: Failed to initialize tab ${this.state.tabId}:`,e),e}}async attemptLeadershipAcquisition(){if(!("locks"in navigator)){r.debug(`COORDINATION: Web Locks not available, tab ${this.state.tabId} becomes leader`),this.state.role="leader";return}try{r.debug(`COORDINATION: Tab ${this.state.tabId} attempting to acquire leadership lock`),navigator.locks.request("auditomatic-leader",{mode:"exclusive",ifAvailable:!0},e=>{if(e)return r.debug(`COORDINATION: Tab ${this.state.tabId} acquired leadership lock`),this.state.role="leader",new Promise(t=>{this.lockReleaseFunction=t});r.debug(`COORDINATION: Tab ${this.state.tabId} could not acquire lock - observer mode`),this.state.role="observer"}),await new Promise(e=>setTimeout(e,50))}catch(e){console.error(`COORDINATION: Leadership acquisition failed for tab ${this.state.tabId}:`,e),this.state.role="observer"}}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.state.lastHeartbeat=new Date,this.broadcast({type:"heartbeat",tabId:this.state.tabId,timestamp:this.state.lastHeartbeat})},1e4)}broadcast(e){this.broadcastChannel&&(r.debug(`COORDINATION: Broadcasting ${e.type} from tab ${this.state.tabId}`),this.broadcastChannel.postMessage(e))}handleCoordinationMessage(e){if(e.tabId!==this.state.tabId)switch(r.debug(`COORDINATION: Tab ${this.state.tabId} received ${e.type} from ${e.tabId}`),e.type){case"execution:started":this.state.role==="observer"&&e.trialId&&r.debug(`COORDINATION: Observer tab syncing to started execution: ${e.trialId}`);break;case"execution:paused":this.state.role==="observer"&&e.trialId&&r.debug(`COORDINATION: Observer tab syncing to paused execution: ${e.trialId}`);break;case"execution:resumed":this.state.role==="observer"&&e.trialId&&r.debug(`COORDINATION: Observer tab syncing to resumed execution: ${e.trialId}`);break;case"execution:cancelled":case"execution:completed":this.state.role==="observer"&&e.trialId&&r.debug(`COORDINATION: Observer tab syncing to ended execution: ${e.trialId}`);break;case"heartbeat":r.debug(`COORDINATION: Heartbeat from ${e.tabId}`);break}}canExecuteActions(){return this.state.role==="leader"}validateLeadership(e){return this.state.role!=="leader"?{ok:!1,error:new Error(`Cannot ${e}: only leader tab can execute actions`)}:{ok:!0,value:void 0}}async startExecution(e,t){const a=this.validateLeadership("start execution");if(!a.ok)return a;r.debug(`COORDINATION: Leader starting execution - trial=${e}, orchestrator=${t}`);const s=await E.startExecution(e,t,this.state.tabId);return s.ok&&this.broadcast({type:"execution:started",tabId:this.state.tabId,timestamp:new Date,trialId:e,orchestratorType:t}),s}async pauseExecution(){const e=this.validateLeadership("pause execution");if(!e.ok)return e;r.debug("COORDINATION: Leader pausing execution");const t=await E.pauseExecution();return t.ok&&this.broadcast({type:"execution:paused",tabId:this.state.tabId,timestamp:new Date,trialId:E.trialId.value||void 0}),t}async resumeExecution(e){const t=this.validateLeadership("resume execution");if(!t.ok)return t;r.debug(`COORDINATION: Leader resuming execution for trial ${e}`);const a=await E.resumeExecution(e,this.state.tabId);return a.ok&&this.broadcast({type:"execution:resumed",tabId:this.state.tabId,timestamp:new Date,trialId:e}),a}async cancelExecution(){const e=this.validateLeadership("cancel execution");if(!e.ok)return e;r.debug("COORDINATION: Leader cancelling execution");const t=E.trialId.value,a=await E.cancelExecution();return a.ok&&this.broadcast({type:"execution:cancelled",tabId:this.state.tabId,timestamp:new Date,trialId:t||void 0}),a}async completeExecution(){const e=this.validateLeadership("complete execution");if(!e.ok)return e;r.debug("COORDINATION: Leader completing execution");const t=E.trialId.value,a=await E.completeExecution();return a.ok&&this.broadcast({type:"execution:completed",tabId:this.state.tabId,timestamp:new Date,trialId:t||void 0}),a}destroy(){r.debug(`COORDINATION: Destroying tab ${this.state.tabId}`),this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.lockReleaseFunction&&(this.lockReleaseFunction(),this.lockReleaseFunction=null),this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.state.isInitialized=!1,r.debug(`COORDINATION: Tab ${this.state.tabId} cleanup complete`)}}const w=new be;class Te{async updateTrial(e){r.debug(`ATOMIC_OPS: Updating trial ${e.trialId} - status=${e.status}`);try{const t={};return e.status!==void 0&&(t.status=e.status),e.started!==void 0&&(t.started=e.started),e.completed!==void 0&&(t.completed=e.completed),e.progress!==void 0&&(t.progress=e.progress),await o.trials.update(e.trialId,t),r.debug(`ATOMIC_OPS: Successfully updated trial ${e.trialId}`),{ok:!0,value:void 0}}catch(t){return console.error(`ATOMIC_OPS: Failed to update trial ${e.trialId}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update trial")}}}async resetRunningCallsToPending(e){r.debug(`ATOMIC_OPS: Resetting running calls to pending for trial ${e}`);try{const t=await o.apiCalls.where("trialId").equals(e).and(a=>a.status==="running").toArray();return t.length===0?r.debug(`ATOMIC_OPS: No running calls found for trial ${e}`):(await o.transaction("rw",o.apiCalls,async()=>{for(const a of t)await o.apiCalls.update(a.id,{status:"pending",started:void 0,response:void 0,result:void 0})}),r.debug(`ATOMIC_OPS: Reset ${t.length} running calls to pending for trial ${e}`)),r.debug("V4_TRIAL_DEBUG_PAUSE: Recalculating trial progress after call status changes"),await this.recalculateTrialProgress(e),{ok:!0,value:t.length}}catch(t){return console.error(`ATOMIC_OPS: Failed to reset running calls for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to reset running calls")}}}async getTrialCallCounts(e){r.debug(`ATOMIC_OPS: Getting call counts for trial ${e}`);try{const t=await o.transaction("r",o.apiCalls,async()=>{const a=await o.apiCalls.where("trialId").equals(e).toArray();return{total:a.length,completed:a.filter(s=>s.status==="completed").length,failed:a.filter(s=>s.status==="failed").length,cancelled:a.filter(s=>s.status==="cancelled").length,pending:a.filter(s=>s.status==="pending").length,running:a.filter(s=>s.status==="running").length}});return r.debug(`TRANSACTION_FIX: Trial ${e} call counts (consistent snapshot):`,t),{ok:!0,value:t}}catch(t){return console.error(`ATOMIC_OPS: Failed to get call counts for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to get call counts")}}}async updateApiCallsBatch(e){if(e.length===0)return{ok:!0,value:void 0};r.debug(`ATOMIC_OPS: Updating batch of ${e.length} API calls`);try{return await o.transaction("rw",o.apiCalls,async()=>{for(const t of e){const a={status:t.status};t.started!==void 0&&(a.started=t.started),t.completed!==void 0&&(a.completed=t.completed),t.response!==void 0&&(a.response=t.response),t.error!==void 0&&(a.error=t.error),await o.apiCalls.update(t.callId,a)}}),r.debug(`ATOMIC_OPS: Successfully updated batch of ${e.length} API calls`),{ok:!0,value:void 0}}catch(t){return console.error("ATOMIC_OPS: Failed to update API calls batch:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update API calls batch")}}}async reconcileTrialState(e){r.debug(`ATOMIC_OPS: Reconciling state for trial ${e}`);try{const t=await o.trials.get(e);if(!t)return{ok:!1,error:new Error(`Trial ${e} not found`)};const a=await this.getTrialCallCounts(e);if(!a.ok)return a;const s=a.value;let i=t.status;if(s.running>0?i="running":s.pending>0?i="paused":s.completed===s.total&&s.total>0||s.failed>0&&s.completed+s.failed===s.total?i="completed":s.cancelled>0&&(i="cancelled"),i!==t.status){r.debug(`ATOMIC_OPS: Reconciling trial ${e} status: ${t.status} → ${i}`);const n=await this.updateTrial({trialId:e,status:i,progress:s,...i==="completed"&&{completed:new Date}});if(!n.ok)return n}else r.debug(`ATOMIC_OPS: Trial ${e} status is consistent: ${i}`);return{ok:!0,value:i}}catch(t){return console.error(`ATOMIC_OPS: Failed to reconcile trial ${e} state:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to reconcile trial state")}}}async performCleanupOperations(e){r.debug(`ATOMIC_OPS: Performing cleanup operations for trial ${e}`);try{const t=await this.resetRunningCallsToPending(e);if(!t.ok)return t;const a=await this.reconcileTrialState(e);if(!a.ok)return a;const s={resetCount:t.value,reconciledStatus:a.value};return r.debug(`ATOMIC_OPS: Cleanup complete for trial ${e}:`,s),{ok:!0,value:s}}catch(t){return console.error(`ATOMIC_OPS: Failed cleanup operations for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed cleanup operations")}}}async recalculateTrialProgress(e){var t;try{const a=await o.trials.get(e);if(!a){r.debug(`V4_TRIAL_DEBUG_PAUSE: Trial ${e} not found, cannot recalculate progress`);return}const s=await o.apiCalls.where("trialId").equals(e).toArray();let i=0,n=0,h=0,g=0,p=0;for(const f of s)switch(f.status){case"completed":i++;break;case"failed":n++,((t=f.result)==null?void 0:t.errorType)==="network_error_no_response"&&p++;break;case"cancelled":h++;break;case"running":g++;break}const d=a.progress.total-i-n-h-g,m={total:a.progress.total,completed:i,failed:n,cancelled:h,pending:d,running:g,networkErrors:p};r.debug(`V4_TRIAL_DEBUG_PAUSE: Recalculated progress for trial ${e} - completed: ${i}, failed: ${n}, running: ${g}, pending: ${d}`),await o.trials.update(e,{progress:m}),r.debug("V4_TRIAL_DEBUG_PAUSE: Trial progress updated successfully")}catch(a){console.error(`V4_TRIAL_DEBUG_PAUSE: Failed to recalculate progress for trial ${e}:`,a)}}async performSystemCleanup(){r.debug("ATOMIC_OPS: Performing system-wide cleanup");try{let e=0,t=0;const a=await o.trials.where("status").equals("running").toArray();r.debug(`ATOMIC_OPS: Found ${a.length} active trials for cleanup`);for(const i of a){const n=await this.performCleanupOperations(i.id);if(n.ok)e+=n.value.resetCount,t++;else{const h=n;console.warn(`ATOMIC_OPS: Failed to cleanup trial ${i.id}:`,h.error.message)}}const s={trialsProcessed:t,callsReset:e};return r.debug("ATOMIC_OPS: System cleanup complete:",s),{ok:!0,value:s}}catch(e){return console.error("ATOMIC_OPS: System cleanup failed:",e),{ok:!1,error:e instanceof Error?e:new Error("System cleanup failed")}}}}const _e=new Te;class Ee{constructor(){I(this,"playgroundService",null);I(this,"initialized",!1);I(this,"orchestrators",new Map);I(this,"activeStreams",new Map);I(this,"execution",A(()=>{const e=E.status.value;let t="idle";return e==="running"||e==="starting"||e==="pausing"?t="executing":e==="paused"?t="paused":t="idle",{status:t,currentTrialId:E.trialId.value,startedAt:E.currentState.value.startedAt}}));I(this,"progress",A(()=>({trials:new Map,activeApiCall:null,lastUpdated:new Date})));I(this,"queue",A(()=>({global:{pending:0,executing:0,capacity:0,utilization:0},providers:new Map})));I(this,"tabRole",A(()=>w.role.value));I(this,"isLeader",A(()=>w.isLeader.value));I(this,"canExecute",A(()=>w.isLeader.value&&E.canStart()))}async initialize(){const e=performance.now();if(r.debug(`V4_TRIAL_SWITCH: V4ExecutionControl initialize() ENTRY at ${e}`),r.debug(`V4_SINGLETON_DEBUG: Current initialized flag: ${this.initialized}`),r.debug(`V4_SINGLETON_DEBUG: Active streams count: ${this.activeStreams.size}`),this.initialized){r.debug("V4_SINGLETON_DEBUG: V4ExecutionControl already initialized, returning early - singleton working correctly!");return}try{r.debug("V4_EXECUTION_CONTROL: Initializing with V4 coordination + V3 execution bridge");const t=performance.now();r.debug(`V4_TRIAL_SWITCH: Starting multiTabCoordinator.initialize() at ${(t-e).toFixed(1)}ms`),await w.initialize();const a=performance.now();r.debug(`V4_TRIAL_SWITCH: multiTabCoordinator.initialize() completed in ${(a-t).toFixed(1)}ms`),r.debug("V4_EXECUTION_CONTROL: Performing system cleanup with V4 atomic operations");const s=performance.now();r.debug(`V4_TRIAL_SWITCH: Starting atomicOperations.performSystemCleanup() at ${(s-e).toFixed(1)}ms`);const i=await _e.performSystemCleanup(),n=performance.now();r.debug(`V4_TRIAL_SWITCH: atomicOperations.performSystemCleanup() completed in ${(n-s).toFixed(1)}ms`),i.ok?r.debug("V4_EXECUTION_CONTROL: System cleanup completed:",i.value):console.warn("V4_EXECUTION_CONTROL: System cleanup failed:",i.error);const h=performance.now();r.debug(`V4_TRIAL_SWITCH: Creating PlaygroundExecutionService at ${(h-e).toFixed(1)}ms`),this.playgroundService=new le(async d=>{const m=await this.startTrialWithStreaming(d);return m.ok?{ok:!0,value:m.value.progress$}:m});const g=performance.now();r.debug(`V4_TRIAL_SWITCH: PlaygroundExecutionService created in ${(g-h).toFixed(1)}ms`),this.initialized=!0;const p=performance.now();r.debug(`V4_TRIAL_SWITCH: V4ExecutionControl initialization TOTAL: ${(p-e).toFixed(1)}ms`),r.debug("V4_EXECUTION_CONTROL: Initialization complete")}catch(t){const a=performance.now();throw console.error(`V4_TRIAL_SWITCH: V4ExecutionControl initialization FAILED in ${(a-e).toFixed(1)}ms:`,t),t}}cleanup(){r.debug("V4_SINGLETON_DEBUG: cleanup() called - this will reset initialized flag and destroy singleton!"),r.debug(`V4_SINGLETON_DEBUG: Current active streams: ${this.activeStreams.size}`),r.debug(`V4_SINGLETON_DEBUG: Current orchestrators: ${this.orchestrators.size}`);try{this.activeStreams.forEach((e,t)=>{r.debug(`V4_SINGLETON_DEBUG: Cleaning up streams for trial ${t}`),e.subscription.unsubscribe()}),this.activeStreams.clear(),this.orchestrators.forEach((e,t)=>{r.debug(`V4_SINGLETON_DEBUG: Cleaning up orchestrator for trial ${t}`)}),this.orchestrators.clear(),w.destroy(),this.playgroundService=null,this.initialized=!1,r.debug("V4_SINGLETON_DEBUG: Cleanup complete - singleton destroyed, will reinitialize on next call")}catch(e){console.error("V4_EXECUTION_CONTROL: Cleanup error:",e)}}async startTrial(e){var t;this.initialized||await this.initialize(),r.debug(`V4_EXECUTION_CONTROL: Starting trial ${e} with V4+V3 bridge`);try{if(F(e)){const h=await(((t=this.playgroundService)==null?void 0:t.executePlaygroundCall("",{}))||Promise.resolve({ok:!1,error:new Error("Playground service not available")}));return h.ok?{ok:!0,value:void 0}:{ok:!1,error:h.error}}let s=this.orchestrators.get(e);s||(r.debug("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",e),s=D(),this.orchestrators.set(e,s));const n=await s.startTrialAtomic(e);return n.ok?(r.debug(`V4_EXECUTION_CONTROL: Successfully started trial ${e} via bridge`),{ok:!0,value:void 0}):{ok:!1,error:n.error}}catch(a){return console.error(`V4_EXECUTION_CONTROL: Failed to start trial ${e}:`,a),{ok:!1,error:a instanceof Error?a:new Error("Failed to start trial")}}}async startTrialWithStreaming(e){this.initialized||await this.initialize(),r.debug(`V4_EXECUTION_CONTROL: Starting streaming trial ${e}`),this.cleanupStreams(e);try{if(F(e))return r.debug("V4_EXECUTION_CONTROL: Playground trial detected, using specialized handling"),{ok:!1,error:new Error("Playground streaming not yet implemented in V4")};if(!this.canExecute.value)return r.debug("V4_EXECUTION_CONTROL: Cannot start - not leader or invalid state"),{ok:!1,error:new Error("Cannot start trial - not leader or invalid state")};r.debug("V4_EXECUTION_CONTROL: Updating state machine to running");const a=w.tabId.value,s=await E.startExecution(e,"streaming",a);if(!s.ok)return r.debug("V4_EXECUTION_CONTROL: State machine update failed:",s.error),{ok:!1,error:s.error};let i=this.orchestrators.get(e);i||(r.debug("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",e),i=D(),this.orchestrators.set(e,i)),r.debug("V4_EXECUTION_CONTROL: Calling V3 orchestrator startTrialAtomicWithStreaming");const n=await i.startTrialAtomicWithStreaming(e);if(!n.ok)return{ok:!1,error:n.error};r.debug("V4_EXECUTION_CONTROL: Creating hot observables without accumulation"),r.debug(`V4_EXECUTION_CONTROL: Creating hot observables for trial ${e}`);const h=n.value.progress$.pipe(W(),he({bufferSize:1,refCount:!0})),g=new ue,p=new J(1),d=n.value.calls$.pipe(ce(f=>(r.debug(`V4_EXECUTION_CONTROL: Batch of ${f.length} calls from pipeline`),f.map(b=>b.call&&b.providerId?b.call:b)))).subscribe({next:f=>{r.debug(`V4_EXECUTION_CONTROL: Forwarding ${f.length} calls to subject`),p.next(f)},error:f=>{r.debug("V4_TRIAL_ERROR: Error in calls stream:",f),p.error(f)},complete:()=>{r.debug(`V4_TRIAL_COMPLETE: Original calls stream completed for trial ${e}`)}});g.add(d);const m=p;return r.debug("V4_TRIAL_REF_TEST: callsSubject === sharedCalls$?",p===m),g.add(h.subscribe({next:f=>{r.debug(`V4_TRIAL_DEBUG_COMPLETION: Progress update for trial ${e}: ${f.type}`),(f.type==="completed"||f.type==="error")&&(r.debug(`V4_TRIAL_DEBUG_COMPLETION: Trial ${e} ${f.type}, scheduling cleanup in 1000ms`),r.debug(`V4_TRIAL_DEBUG_COMPLETION: Current execution state: ${E.status.value}`),r.debug("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to completed/cancelled state"),f.type==="completed"?(r.debug("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.completeExecution()"),w.completeExecution().then(b=>{b.ok?(r.debug("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to completed successfully"),r.debug(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${E.status.value}`)):console.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer completion update failed:",b.error)})):(r.debug("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.cancelExecution() for error"),w.cancelExecution().then(b=>{b.ok?(r.debug("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled successfully"),r.debug(`V4_TRIAL_DEBUG_COMPLETION: Post-cancellation execution state: ${E.status.value}`)):console.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer cancellation update failed:",b.error)})),setTimeout(()=>{r.debug(`V4_TRIAL_DEBUG_COMPLETION: Executing delayed cleanup for trial ${e}`),r.debug(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${E.status.value}`),this.cleanupStreams(e),this.orchestrators.has(e)&&(r.debug(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for completed trial ${e}`),this.orchestrators.delete(e))},1e3))},error:f=>{console.error(`V4_TRIAL_DEBUG_COMPLETION: Stream error for trial ${e}:`,f),r.debug("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to cancelled state due to error"),w.cancelExecution().then(b=>{b.ok?(r.debug("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled after error"),r.debug(`V4_TRIAL_DEBUG_COMPLETION: Post-error execution state: ${E.status.value}`)):console.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer error cancellation failed:",b.error)}),this.cleanupStreams(e),this.orchestrators.has(e)&&(r.debug(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for errored trial ${e}`),this.orchestrators.delete(e))}})),r.debug(`V4_TRIAL_STORE: Storing activeStreams for trial ${e}`),this.activeStreams.set(e,{streams:n.value,subscription:g,sharedProgress$:h,sharedCalls$:m,callsSubject:p}),r.debug(`V4_EXECUTION_CONTROL: Successfully created hot observables for trial ${e}`),{ok:!0,value:n.value}}catch(t){return console.error(`V4_EXECUTION_CONTROL: Failed to start streaming trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to start streaming trial")}}}async pauseExecution(){this.initialized||await this.initialize();const e=E.trialId.value;if(r.debug(`V4_TRIAL_DEBUG_PAUSE: pauseExecution() ENTRY for trial ${e||"NONE"}`),r.debug(`V4_TRIAL_DEBUG_PAUSE: Current execution state: ${E.status.value}`),r.debug(`V4_TRIAL_DEBUG_PAUSE: Active streams count: ${this.activeStreams.size}`),!e)return r.debug("V4_TRIAL_DEBUG_PAUSE: ERROR - No active trial to pause"),{ok:!1,error:new Error("No active trial to pause")};if(!E.canPause())return r.debug("V4_TRIAL_DEBUG_PAUSE: Cannot pause - invalid state"),{ok:!1,error:new Error("Cannot pause in current state")};r.debug("V4_TRIAL_DEBUG_PAUSE: Updating state machine to paused");const t=await E.pauseExecution();if(!t.ok)return r.debug("V4_TRIAL_DEBUG_PAUSE: State machine update failed:",t.error),t;r.debug("V4_TRIAL_DEBUG_PAUSE: Calling V3 orchestrator pauseTrial");const a=this.orchestrators.get(e);return a&&(await a.pauseTrial(),r.debug("V4_TRIAL_DEBUG_PAUSE: Keeping orchestrator alive for potential hot resume")),w.pauseExecution(),r.debug("V4_TRIAL_DEBUG_PAUSE: Pause successful"),{ok:!0,value:void 0}}async resumeExecution(e){this.initialized||await this.initialize();const t=e||E.trialId.value;if(r.debug(`V4_TRIAL_DEBUG_RESUME: resumeExecution() ENTRY for trial ${t||"NONE"}`),r.debug(`V4_TRIAL_DEBUG_RESUME: Current execution state: ${E.status.value}`),r.debug(`V4_TRIAL_DEBUG_RESUME: Active streams count: ${this.activeStreams.size}`),r.debug(`V4_TRIAL_DEBUG_RESUME: Provided trialId: ${e||"NONE"}, state trialId: ${E.trialId.value||"NONE"}`),!t)return r.debug("V4_TRIAL_DEBUG_RESUME: ERROR - No trial ID provided and no active trial to resume"),{ok:!1,error:new Error("No trial ID provided and no active trial to resume")};if(!E.canResume())return r.debug("V4_TRIAL_DEBUG_RESUME: Cannot resume - invalid state"),{ok:!1,error:new Error("Cannot resume in current state")};r.debug("V4_TRIAL_DEBUG_RESUME: Updating state machine to running");const a=w.tabId.value,s=await E.resumeExecution(t,a);if(!s.ok)return r.debug("V4_TRIAL_DEBUG_RESUME: State machine update failed:",s.error),s;let i=this.orchestrators.get(t);if(i)r.debug(`V4_TRIAL_DEBUG_RESUME: HOT RESUME - Found existing orchestrator for trial ${t}`),r.debug("V4_TRIAL_DEBUG_RESUME: Calling orchestrator.resumeTrial() to flip pause$ and resume pipeline"),i.resumeTrial();else{r.debug(`V4_TRIAL_DEBUG_RESUME: COLD RESUME - No orchestrator found for trial ${t}`),r.debug("V4_TRIAL_DEBUG_RESUME: Creating fresh orchestrator and starting with pending calls"),i=D(),this.orchestrators.set(t,i),r.debug("V4_TRIAL_DEBUG_RESUME: Calling startTrialAtomicWithStreaming to create new pipeline");const n=await i.startTrialAtomicWithStreaming(t);if(!n.ok)return console.error("V4_TRIAL_DEBUG_RESUME: Failed to start trial for cold resume:",n.error),{ok:!1,error:n.error};r.debug("V4_TRIAL_DEBUG_RESUME: Cold resume successful, storing new streams")}return w.resumeExecution(t),r.debug("V4_TRIAL_DEBUG_RESUME: Resume successful"),{ok:!0,value:void 0}}async cancelExecution(){this.initialized||await this.initialize(),r.debug("V4_EXECUTION_CONTROL: Cancelling execution");const e=E.trialId.value;if(!e)return{ok:!1,error:new Error("No active trial to cancel")};if(!E.canCancel())return r.debug("V4_EXECUTION_CONTROL: Cannot cancel - invalid state"),{ok:!1,error:new Error("Cannot cancel in current state")};r.debug("V4_EXECUTION_CONTROL: Updating state machine to cancelled");const t=await E.cancelExecution();if(!t.ok)return r.debug("V4_EXECUTION_CONTROL: State machine update failed:",t.error),t;r.debug("V4_EXECUTION_CONTROL: Calling V3 orchestrator cancelTrial");const a=this.orchestrators.get(e);return a&&(a.cancelTrial(),r.debug("V4_EXECUTION_CONTROL: Removing orchestrator after cancel"),this.orchestrators.delete(e)),w.cancelExecution(),this.cleanupStreams(e),r.debug("V4_EXECUTION_CONTROL: Cancel successful"),{ok:!0,value:void 0}}async executeSingleCall(e,t,a){return this.initialized||await this.initialize(),this.playgroundService?this.playgroundService.executePlaygroundCall(e,a):{ok:!1,error:new Error("Playground service not initialized")}}getActiveStreams(e){const t=this.activeStreams.get(e);return r.debug(`V4_TRIAL_GET: getActiveStreams(${e}) called, found: ${!!t}, has sharedCalls$: ${!!(t!=null&&t.sharedCalls$)}`),t}cleanupStreams(e){r.debug(`V4_TRIAL_DEBUG_CLEANUP: cleanupStreams() ENTRY for trial ${e}`),r.debug(`V4_TRIAL_DEBUG_CLEANUP: Current execution state: ${E.status.value}`),r.debug(`V4_TRIAL_DEBUG_CLEANUP: Current state trialId: ${E.trialId.value}`);const t=this.activeStreams.get(e);t?(r.debug(`V4_TRIAL_DEBUG_CLEANUP: Found streams for trial ${e}, unsubscribing`),t.subscription.unsubscribe(),this.activeStreams.delete(e),r.debug(`V4_TRIAL_DEBUG_CLEANUP: Cleaned up streams, remaining active streams: ${this.activeStreams.size}`)):r.debug(`V4_TRIAL_DEBUG_CLEANUP: No streams found for trial ${e} (already cleaned up?)`)}}let x=null;function ye(){return x||(x=new Ee),x}class Ce{async createTrial(e){try{const t=this.validateTrialConfig(e);if(!t.ok)return{ok:!1,error:t.error};const a=await this.createConfigurationSnapshots(e.configurations),s={id:$("trial"),name:e.name,description:e.description,type:e.type,status:"draft",configurations:a,progress:{total:0,completed:0,failed:0,cancelled:0,pending:0,running:0,networkErrors:0},created:new Date,...e.repeatCount&&e.repeatCount>1?{repeatConfig:{callsPerPrompt:e.repeatCount}}:{},...e.type==="template"&&e.templateConfig?{templateConfig:{...e.templateConfig,template:e.templateConfig.template,variables:e.templateConfig.variables,outputType:e.templateConfig.outputType,extractPattern:e.templateConfig.extractPattern,refusalWords:e.templateConfig.refusalWords,rejectRefusalWords:e.templateConfig.rejectRefusalWords}}:{},...e.type==="spreadsheet"&&e.spreadsheetConfig?{spreadsheetConfig:e.spreadsheetConfig}:{}},i=await this.generateApiCalls(s,e.repeatCount||1);return s.progress.total=i.length,s.progress.pending=i.length,await o.transaction("rw",o.trials,o.apiCalls,async()=>{await o.trials.add(s),i.length>0&&await o.apiCalls.bulkAdd(i)}),r.debug(`V4_TRIALS: Created trial ${s.id} with ${i.length} API calls`),{ok:!0,value:s.id}}catch(t){return console.error("V4_TRIALS: Failed to create trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to create trial")}}}async updateTrial(e,t){try{return await o.transaction("rw",o.trials,async()=>{const a=await o.trials.get(e);if(!a)throw new Error(`Trial not found: ${e}`);const s={...a,...t,created:a.created};await o.trials.put(s)}),{ok:!0}}catch(a){return console.error("V4_TRIALS: Failed to update trial:",a),{ok:!1,error:a instanceof Error?a:new Error("Failed to update trial")}}}async deleteTrial(e){try{return await o.transaction("rw",o.trials,o.apiCalls,async()=>{const t=await o.trials.get(e);if(!t)throw new Error(`Trial not found: ${e}`);if(t.status==="running")throw new Error("Cannot delete running trial");await o.apiCalls.where("trialId").equals(e).delete(),await o.trials.delete(e)}),r.debug(`V4_TRIALS: Deleted trial ${e} and all associated API calls`),{ok:!0}}catch(t){return console.error("V4_TRIALS: Failed to delete trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to delete trial")}}}async duplicateTrial(e){try{const t=await o.trials.get(e);if(!t)return{ok:!1,error:new Error(`Source trial not found: ${e}`)};const a={name:`${t.name} (Copy)`,description:t.description,type:t.type,configurations:t.configurations.map(s=>{var i;return{provider:s.provider,modelId:s.modelId,parameters:s.parameters,name:(i=s.modelSnapshot)==null?void 0:i.displayName}}),repeatCount:t.repeatCount,...t.type==="template"&&t.templateConfig?{templateConfig:t.templateConfig}:{},...t.type==="spreadsheet"&&t.spreadsheetConfig?{spreadsheetConfig:t.spreadsheetConfig}:{}};return this.createTrial(a)}catch(t){return console.error("V4_TRIALS: Failed to duplicate trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to duplicate trial")}}}async updateTrialProgress(e){try{return await o.transaction("rw",o.trials,o.apiCalls,async()=>{var d;const t=await o.trials.get(e);if(!t)throw new Error(`Trial not found: ${e}`);const a=await o.apiCalls.where("trialId").equals(e).toArray();let s=0,i=0,n=0,h=0,g=0;for(const m of a)switch(m.status){case"completed":s++;break;case"failed":i++,((d=m.result)==null?void 0:d.errorType)==="network_error_no_response"&&g++;break;case"cancelled":n++;break;case"running":h++;break}const p=t.progress.total-s-i-n-h;t.progress={total:t.progress.total,completed:s,failed:i,cancelled:n,pending:p,running:h,networkErrors:g},s+i+n>=t.progress.total&&t.status==="running"&&(t.status="completed",t.completed=new Date),await o.trials.put(t)}),{ok:!0}}catch(t){return console.error("V4_TRIALS: Failed to update trial progress:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update progress")}}}async generateApiCalls(e,t){return r.debug(`V4_TRIALS: Generating REAL API calls for trial ${e.id}, type: ${e.type}`),e.type==="template"&&e.templateConfig?this.generateTemplateApiCalls(e,e.templateConfig,t):e.type==="spreadsheet"&&e.spreadsheetConfig?this.generateSpreadsheetApiCalls(e,e.spreadsheetConfig,t):e.type==="playground"?[]:(console.warn(`V4_TRIALS: Unknown trial type or missing config for trial ${e.id}`),[])}async generateTemplateApiCalls(e,t,a){if(!t)return[];const s=[];let i=0;const n=await this.generateVariableCombinations(t.variables);r.debug(`V4_TRIALS: Generated ${n.length} variable combinations`);for(let h=0;h<a;h++)for(let g=0;g<e.configurations.length;g++)for(const p of n){const d=this.substituteVariables(t.template,p.variables),m={id:$("call"),trialId:e.id,configurationIndex:g,order:i++,variables:p.variables,variableAttributes:p.variableAttributes,prompt:d,status:"pending",retryCount:0,created:new Date};s.push(m)}return r.debug(`V4_TRIALS: Generated ${s.length} REAL API calls for template trial`),s}async generateSpreadsheetApiCalls(e,t,a){var h;if(!t)return[];const s=[];let i=0;const n=await o.variableLists.get(t.datasetId);if(!n||n.category!=="tabular"||!((h=n.tabularData)!=null&&h.rows))return console.warn(`V4_TRIALS: Dataset ${t.datasetId} not found or invalid`),[];for(let g=0;g<a;g++)for(const p of n.tabularData.rows){const d=this.substituteVariables(t.promptPattern,p);for(let m=0;m<e.configurations.length;m++){const f={id:$("call"),trialId:e.id,configurationIndex:m,order:i++,variables:p,prompt:d,status:"pending",retryCount:0,created:new Date};s.push(f)}}return r.debug(`V4_TRIALS: Generated ${s.length} REAL API calls for spreadsheet trial`),s}async generateVariableCombinations(e){var h;const t=Object.keys(e).sort();if(t.length===0)return[{variables:{}}];const a={};for(const g of t){const p=e[g];let d=[];if(p.type==="value"&&p.values)d=p.values.map(m=>({value:m}));else if(p.type==="list"&&p.listId){const m=await o.variableLists.get(p.listId);m&&(m.category==="simple"&&m.values?d=m.values.map(f=>({value:f})):m.category==="attributed"&&m.items?d=m.items.map(f=>({value:f.value||f.name||String(f),attributes:f.attributes||{}})):m.category==="tabular"&&((h=m.tabularData)!=null&&h.rows)&&(d=m.tabularData.rows.map(f=>({value:f.name||f[Object.keys(f)[0]]||String(f)}))))}a[g]=d}const i=t.map(g=>Math.max(a[g].length,1)).reduce((g,p)=>g*p,1),n=[];for(let g=0;g<i;g++){const p={},d={};let m=g;for(let b=t.length-1;b>=0;b--){const R=t[b],T=a[R];if(T.length>0){const c=m%T.length,u=T[c];p[R]=u.value,u.attributes&&Object.keys(u.attributes).length>0&&(d[R]={...u.attributes}),m=Math.floor(m/T.length)}else p[R]=""}const f={variables:p};Object.keys(d).length>0&&(f.variableAttributes=d),n.push(f)}return n}substituteVariables(e,t){let a=e;for(const[s,i]of Object.entries(t)){const n=new RegExp(`\\{\\{\\s*${s}\\s*\\}\\}`,"g");a=a.replace(n,i)}return a}validateTrialConfig(e){var t;if(!e.name||e.name.trim().length===0)return{ok:!1,error:new Error("Trial name is required")};if(!e.configurations||e.configurations.length===0)return{ok:!1,error:new Error("At least one model configuration is required")};for(const a of e.configurations){if(!k.getProvider(a.provider))return{ok:!1,error:new Error(`Provider not found: ${a.provider}`)};const i=k.validateParameters(a.provider,a.modelId,a.parameters);if(!i.valid)return{ok:!1,error:new Error(`Invalid parameters: ${((t=i.errors)==null?void 0:t.join(", "))||"Validation failed"}`)}}if(e.type==="template"){if(!e.templateConfig||!e.templateConfig.template)return{ok:!1,error:new Error("Template is required for template trials")}}else if(e.type==="spreadsheet"&&(!e.spreadsheetConfig||!e.spreadsheetConfig.promptPattern))return{ok:!1,error:new Error("Prompt pattern is required for spreadsheet trials")};return{ok:!0}}async createConfigurationSnapshots(e){const t=[];for(const a of e){const s=k.getProvider(a.provider);if(!s)throw new Error(`Provider not found: ${a.provider}`);const n=(await o.models.where("provider").equals(a.provider).toArray()).find(g=>g.modelId===a.modelId),h={provider:a.provider,modelId:a.modelId,parameters:a.parameters,providerSnapshot:s,modelSnapshot:n||{id:`${a.provider}:${a.modelId}`,provider:a.provider,modelId:a.modelId,displayName:a.name||a.modelId,enabled:!0,source:"user"}};t.push(h)}return t}}const V=new Ce;function we(){const l=N(!1),e=N(!1),t=N(!1),a=N(!1),s=N(null),i=async c=>{l.value=!0,s.value=null;try{r.debug("V4_TRIAL_COMMANDS: Creating trial with config:",c);const u=await V.createTrial(c);return u.ok?r.debug("V4_TRIAL_COMMANDS: Trial created successfully:",u.value):(s.value=u.error||new Error("Failed to create trial"),console.error("V4_TRIAL_COMMANDS: Create trial failed:",u.error)),u}finally{l.value=!1}},n=async(c,u,_)=>{try{const C=await o.template_prompts.get(c);if(!C)return{ok:!1,error:new Error(`Template not found: ${c}`)};const v={name:_||`${C.name} - ${new Date().toLocaleString()}`,description:C.description,type:"template",configurations:u,repeatCount:1,templateConfig:{template:C.template,variables:C.variables||{},outputType:C.outputType,extractPattern:C.extractPattern,refusalWords:C.refusalWords?[...C.refusalWords]:void 0,rejectRefusalWords:C.rejectRefusalWords}};return i(v)}catch(C){return console.error("V4_TRIAL_COMMANDS: Failed to create trial from template:",C),{ok:!1,error:C instanceof Error?C:new Error("Failed to create trial from template")}}},h=async(c,u,_,C)=>{try{const v=await o.variableLists.get(u);if(!v||v.category!=="tabular")return{ok:!1,error:new Error(`Dataset not found or not tabular: ${u}`)};const y={name:C||`Spreadsheet Trial - ${new Date().toLocaleString()}`,type:"spreadsheet",configurations:_,spreadsheetConfig:{promptPattern:c,datasetId:u}};return i(y)}catch(v){return console.error("V4_TRIAL_COMMANDS: Failed to create spreadsheet trial:",v),{ok:!1,error:v instanceof Error?v:new Error("Failed to create spreadsheet trial")}}},g=async(c,u)=>{e.value=!0,s.value=null;try{const _=await V.updateTrial(c,u);return _.ok||(s.value=_.error||new Error("Failed to update trial"),console.error("V4_TRIAL_COMMANDS: Update trial failed:",_.error)),_}finally{e.value=!1}},p=async(c,u)=>g(c,{status:u}),d=async c=>{t.value=!0,s.value=null;try{r.debug("V4_TRIAL_COMMANDS: Deleting trial:",c);const u=await V.deleteTrial(c);return u.ok?r.debug("V4_TRIAL_COMMANDS: Trial deleted successfully"):(s.value=u.error||new Error("Failed to delete trial"),console.error("V4_TRIAL_COMMANDS: Delete trial failed:",u.error)),u}finally{t.value=!1}},m=async c=>{t.value=!0,s.value=null;try{return r.debug("V4_TRIAL_COMMANDS: Deleting multiple trials:",c.length),await o.transaction("rw",o.trials,o.apiCalls,async()=>{for(const u of c){const _=await o.trials.get(u);_&&_.status!=="running"&&(await o.apiCalls.where("trialId").equals(u).delete(),await o.trials.delete(u))}}),r.debug("V4_TRIAL_COMMANDS: Multiple trials deleted successfully"),{ok:!0}}catch(u){return console.error("V4_TRIAL_COMMANDS: Failed to delete multiple trials:",u),s.value=u instanceof Error?u:new Error("Failed to delete trials"),{ok:!1,error:s.value}}finally{t.value=!1}},f=async c=>{a.value=!0,s.value=null;try{r.debug("V4_TRIAL_COMMANDS: Duplicating trial:",c);const u=await V.duplicateTrial(c);return u.ok?r.debug("V4_TRIAL_COMMANDS: Trial duplicated successfully:",u.value):(s.value=u.error||new Error("Failed to duplicate trial"),console.error("V4_TRIAL_COMMANDS: Duplicate trial failed:",u.error)),u}finally{a.value=!1}},b=async c=>{var u,_;try{let C=1;if(c.type==="template"&&c.templateConfig){const y=c.templateConfig.variables;for(const[,S]of Object.entries(y))if(S.type==="value"&&S.values)C*=S.values.length;else if(S.type==="list"&&S.listId){const O=await o.variableLists.get(S.listId);O&&(O.category==="simple"&&O.values?C*=O.values.length:O.category==="attributed"&&O.items?C*=O.items.length:O.category==="tabular"&&((u=O.tabularData)!=null&&u.rows)&&(C*=O.tabularData.rows.length))}}else if(c.type==="spreadsheet"&&c.spreadsheetConfig){const y=await o.variableLists.get(c.spreadsheetConfig.datasetId);y&&y.category==="tabular"&&((_=y.tabularData)!=null&&_.rows)&&(C=y.tabularData.rows.length)}return C*c.configurations.length*(c.repeatCount||1)}catch(C){return console.error("V4_TRIAL_COMMANDS: Failed to calculate API call count:",C),0}};return{createTrial:i,createTrialFromTemplate:n,createTrialFromSpreadsheet:h,updateTrial:g,updateTrialStatus:p,deleteTrial:d,deleteMultipleTrials:m,duplicateTrial:f,generateApiCallCount:b,estimateTrialCost:async c=>{var u,_;try{const C=await b(c);let v=0;for(const y of c.configurations){const O=(await o.models.where("provider").equals(y.provider).toArray()).find(P=>P.modelId===y.modelId);if(O!=null&&O.capabilities){const K=((u=y.parameters)==null?void 0:u.max_tokens)||((_=y.parameters)==null?void 0:_.maxTokens)||256,ee=(O.capabilities.inputCostPerToken||0)*150,te=(O.capabilities.outputCostPerToken||0)*K;v+=(ee+te)*C/c.configurations.length}}return v}catch(C){return console.error("V4_TRIAL_COMMANDS: Failed to estimate cost:",C),0}},validateTrialConfig:c=>!c.name||c.name.trim().length===0?{ok:!1,error:new Error("Trial name is required")}:!c.configurations||c.configurations.length===0?{ok:!1,error:new Error("At least one model configuration is required")}:c.type==="template"&&!c.templateConfig?{ok:!1,error:new Error("Template configuration is required for template trials")}:c.type==="spreadsheet"&&!c.spreadsheetConfig?{ok:!1,error:new Error("Spreadsheet configuration is required for spreadsheet trials")}:{ok:!0},isCreating:l,isUpdating:e,isDeleting:t,isDuplicating:a,lastError:s}}export{Q as C,Z as F,we as a,ye as b,Oe as c,Ae as u};
