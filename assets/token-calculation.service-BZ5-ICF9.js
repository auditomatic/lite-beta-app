var e=Object.defineProperty,t=(t,a,i)=>((t,a,i)=>a in t?e(t,a,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[a]=i)(t,"symbol"!=typeof a?a+"":a,i);import{l as a,a4 as i,g as r}from"./index--f-h8q18.js";import{v as n}from"./variable.service-Cx9TK-Dm.js";const s=class e{calculateTotalPermutations(e){const t=Object.values(e).filter(e=>e>0);return 0===t.length?0:t.reduce((e,t)=>e*t,1)}getPermutationInfo(t){const a=this.calculateTotalPermutations(t);let i,r;return i=a>999999?`${(a/1e6).toFixed(1)}M`:a>9999?`${(a/1e3).toFixed(0)}k`:a.toLocaleString(),a>e.VERY_LARGE_THRESHOLD?r="Very large trial - may take hours and significant API costs":a>e.LARGE_THRESHOLD&&(r="Large trial - consider sampling or filtering"),{total:a,isLarge:a>e.LARGE_THRESHOLD,formatted:i,warning:r}}*generatePermutations(e,t=1/0){const a=Object.keys(e),i=a.map(t=>e[t]);if(0===a.length)return;let r=0;const n=function*(e,s){if(r>=t)return;if(e===a.length)return yield{...s},void r++;const o=a[e],l=i[e];for(const a of l){if(r>=t)return;s[o]=a,yield*n(e+1,s)}};yield*n(0,{})}getSamplePermutations(e,t=5){const a=[],i=this.generatePermutations(e,t);for(const r of i)a.push(r);return a}estimateTrialMetrics(e,t,a=2e3,i=.01){const r=e*t,n=r*a*.7;return{totalCalls:r,estimatedTimeMinutes:Math.ceil(n/6e4),estimatedCostUSD:r*i}}shouldSample(t,a=e.LARGE_THRESHOLD){const i=this.calculateTotalPermutations(t);if(i<=a)return{shouldSample:!1};let r;return r=i>1e6?1e3:i>1e5?5e3:Math.min(1e4,Math.floor(.1*i)),{shouldSample:!0,recommendedSampleSize:r}}*generateStratifiedSample(e,t){const a=this.calculateTotalPermutations(Object.fromEntries(Object.entries(e).map(([e,t])=>[e,t.length])));if(a<=t)return void(yield*this.generatePermutations(e));const i=Math.floor(a/t);let r=0,n=0;for(const s of this.generatePermutations(e))if(r%i===0&&n<t&&(yield s,n++),r++,n>=t)break}};t(s,"LARGE_THRESHOLD",1e4),t(s,"VERY_LARGE_THRESHOLD",1e5);const o=new s;function l(e){return new Worker(""+new URL("token-calculation.worker-_TmsjB_5.js",import.meta.url).href,{name:e?.name})}const c=new class{constructor(){t(this,"worker",null),t(this,"pendingRequests",new Map),t(this,"isWorkerSupported","undefined"!=typeof Worker),t(this,"workerLoadError",null),t(this,"isInitializing",!1),t(this,"isInitialized",!1)}async initializeWorker(){if(!this.isInitialized&&!this.isInitializing&&this.isWorkerSupported){this.isInitializing=!0;try{this.worker=new l,this.worker.addEventListener("message",this.handleWorkerMessage.bind(this)),this.worker.addEventListener("error",this.handleWorkerError.bind(this)),await this.primeWorker(),this.isInitialized=!0,a.info("Persistent token calculation worker initialized and primed")}catch(e){a.error("Failed to initialize token calculation worker",e),this.workerLoadError=e,this.isWorkerSupported=!1,this.worker=null}finally{this.isInitializing=!1}}}async primeWorker(){if(!this.worker)return;const e=`prime-${Date.now()}`;return new Promise((t,a)=>{const i=setTimeout(()=>{this.pendingRequests.delete(e),a(new Error("Worker priming timeout"))},3e4);this.pendingRequests.set(e,{resolve:()=>{clearTimeout(i),t()},reject:e=>{clearTimeout(i),a(e)}}),this.worker.postMessage({id:e,method:"accurate",design:{id:"prime",promptTemplate:"test",variableBindings:{},executionMode:"cartesian"}})})}async ensureWorkerReady(){if(!this.isWorkerSupported)throw new Error("Workers not supported in this environment");if(this.workerLoadError)throw this.workerLoadError;for(this.isInitialized||this.isInitializing||await this.initializeWorker();this.isInitializing;)await new Promise(e=>setTimeout(e,50));if(!this.worker||!this.isInitialized)throw new Error("Worker failed to initialize")}handleWorkerMessage(e){const t=e.data,i=this.pendingRequests.get(t.id);if(i)switch(t.type){case"progress":i.onProgress?.(t);break;case"result":i.resolve(t.result),this.pendingRequests.delete(t.id);break;case"error":i.reject(new Error(t.error.message)),this.pendingRequests.delete(t.id)}else a.warn("Received message for unknown request",{messageId:t.id})}handleWorkerError(e){a.error("Worker error",e),this.pendingRequests.forEach(e=>{e.reject(new Error("Worker crashed"))}),this.pendingRequests.clear(),this.worker?.terminate(),this.worker=null,setTimeout(()=>{this.isWorkerSupported&&this.initializeWorker()},1e3)}async prepareDesignData(e){const t=JSON.parse(JSON.stringify(e)),i={};for(const[s,o]of Object.entries(t.variableBindings||{}))if("list"===o.type&&o.listId)try{const e=await n.getListValues(o.listId);i[s]={type:"direct",values:[...e]}}catch(r){a.warn("Failed to resolve list values for variable",{error:r,varName:s}),i[s]={type:"direct",values:[]}}else i[s]=JSON.parse(JSON.stringify(o));return{id:t.id,promptTemplate:t.promptTemplate,variableBindings:i,executionMode:t.executionMode}}async calculateApproximate(e){try{await this.ensureWorkerReady()}catch(i){throw new Error("Worker not available for approximate calculation")}const t=`${e.id}-${Date.now()}-${Math.random()}`,a=await this.prepareDesignData(e);return new Promise((e,i)=>{this.pendingRequests.set(t,{resolve:e,reject:i});const r={id:t,method:"approximate",design:a};this.worker.postMessage(r),setTimeout(()=>{this.pendingRequests.has(t)&&(this.pendingRequests.delete(t),i(new Error("Worker timeout")))},5e3)})}async calculateAccurate(e,t){try{await this.ensureWorkerReady()}catch(n){throw a.warn("Worker not available for accurate calculation",{error:n}),new Error("Worker not available for accurate calculation")}const i=`${e.id}-${Date.now()}-${Math.random()}`,r=await this.prepareDesignData(e);return new Promise((e,a)=>{this.pendingRequests.set(i,{resolve:e,reject:a,onProgress:t});const n={id:i,method:"accurate",design:r};this.worker.postMessage(n),setTimeout(()=>{this.pendingRequests.has(i)&&(this.pendingRequests.delete(i),a(new Error("Worker timeout - calculation taking too long")))},1e4)})}isWorkerAvailable(){return this.isWorkerSupported&&null===this.workerLoadError}terminate(){this.worker&&(this.pendingRequests.forEach(e=>{e.reject(new Error("Worker terminated"))}),this.pendingRequests.clear(),this.worker.terminate(),this.worker=null,this.isInitialized=!1,this.isInitializing=!1,a.info("Persistent token calculation worker terminated"))}};const u=new class{constructor(){t(this,"tokenCountCache",new Map)}async calculateDesignTokens(e){try{const i=this.getDesignCacheKey(e),r=this.tokenCountCache.get(i);if(r&&r.calculated&&Date.now()-r.calculated.getTime()<36e5)return r;if(a.info("Calculating tokens for design",{designName:e.name}),c.isWorkerAvailable())try{const t=await c.calculateApproximate(e);return a.info("Token calculation complete (worker)",{designName:e.name}),this.tokenCountCache.set(i,t),t}catch(t){a.warn("Worker calculation failed, falling back to simple approximation",{error:t})}if(a.info("Calculating tokens on main thread with variable-aware approximation"),"aligned"===e.executionMode)return this.calculateAlignedDesignTokens(e);const n=e.promptTemplate.replace(/\{\{[^}]+\}\}/g,""),s=await this.countTokens(n),o=await this.getVariableValues(e),l={};for(const[e,t]of Object.entries(o)){if(0===t.length){l[e]={min:0,max:0,avg:0};continue}const a=await Promise.all(t.map(e=>this.countTokens(e)));l[e]={min:Math.min(...a),max:Math.max(...a),avg:Math.round(a.reduce((e,t)=>e+t,0)/a.length)}}let u=s,d=s,m=s;for(const e of Object.values(l))u+=e.min,d+=e.max,m+=e.avg;const h={minTokens:u,maxTokens:d,avgTokens:m,sampleSize:Object.values(o).reduce((e,t)=>e+t.length,0),calculated:new Date,isAccurate:!1};return a.info("Token calculation complete (main thread)",{designName:e.name}),this.tokenCountCache.set(i,h),h}catch(i){return a.error("Failed to calculate design tokens",i),{minTokens:0,maxTokens:0,avgTokens:0,sampleSize:0,calculated:new Date}}}async calculateDesignTokensAccurate(e,t){try{const r=this.getDesignCacheKey(e)+":accurate",n=this.tokenCountCache.get(r);if(n&&n.calculated&&n.isAccurate&&Date.now()-n.calculated.getTime()<36e5)return n;if(c.isWorkerAvailable())try{const i=await c.calculateAccurate(e,t?e=>{t({stage:e.stage,current:e.current,total:e.total,message:e.message})}:void 0);return a.info("Accurate token calculation complete (worker)",{designName:e.name}),this.tokenCountCache.set(r,i),i}catch(i){return a.warn("Worker accurate calculation failed, falling back to approximate",{error:i}),this.calculateDesignTokens(e)}return a.warn("Worker not available for accurate calculation, using approximate"),this.calculateDesignTokens(e)}catch(r){return a.error("Failed to calculate accurate tokens",r),this.calculateDesignTokens(e)}}async calculateCostEstimate(e,t,a){const i=await this.calculateDesignTokens(e),r=this.getOutputTokenLimit(t.provider,t.modelId,a),n=t.capabilities?.inputCostPerToken||0,s=t.capabilities?.outputCostPerToken||0,l={min:i.minTokens*n+r*s,max:i.maxTokens*n+r*s,avg:i.avgTokens*n+r*s},c=await this.getVariableCounts(e),u=o.calculateTotalPermutations(c);return{inputTokens:i,outputTokens:r,costPerCall:l,totalCost:{min:l.min*u,max:l.max*u,avg:l.avg*u},environmentalCosts:undefined}}async calculateCostEstimateFromContext(e,t,a,i){const r={minTokens:Math.floor(.8*t),maxTokens:Math.ceil(1.2*t),avgTokens:t,sampleSize:1,calculated:new Date,isAccurate:!1},n=this.getOutputTokenLimit(a.provider,a.modelId,i),s=a.capabilities?.inputCostPerToken||0,o=a.capabilities?.outputCostPerToken||0,l={min:r.minTokens*s+n*o,max:r.maxTokens*s+n*o,avg:r.avgTokens*s+n*o};return{inputTokens:r,outputTokens:n,costPerCall:l,totalCost:{min:l.min*e,max:l.max*e,avg:l.avg*e},environmentalCosts:undefined}}getOutputTokenLimit(e,t,a){return i.getOutputTokenLimit(e,t,a)}async countTokens(e){return e&&0!==e.length?Math.ceil(e.length/4):0}async getVariableCounts(e){const t={};for(const[a,i]of Object.entries(e.variableBindings||{}))if("direct"===i.type&&i.values)t[a]=i.values.length;else if("list"===i.type&&i.listId){const e=await n.getListValues(i.listId);t[a]=e.length}return t}async getVariableValues(e){const t={};try{for(const[r,s]of Object.entries(e.variableBindings||{}))if("direct"===s.type&&s.values)t[r]=s.values;else if("list"===s.type&&s.listId)try{const e=await n.getListValues(s.listId);t[r]=e}catch(i){a.warn("Failed to get list values for variable",{error:i,varName:r}),t[r]=[]}}catch(i){a.error("Error getting variable values",i)}return t}getDesignCacheKey(e){const t=JSON.stringify(e.variableBindings);return`${e.id}:${e.promptTemplate}:${t}`}async calculateEnvironmentalCostEstimate(e,t,a){return{carbon:0,water:0,energy:0,confidence:"none",source:"no-data"}}async calculateAlignedDesignTokens(e){try{const t=e.variableBindings?.__tabular__;if(!t||"list"!==t.type||!t.listId)throw new Error("Aligned design missing tabular data binding");const a=await r.variableLists.get(t.listId);if(!a||!a.tabularData)throw new Error("Tabular variable list not found or missing data");const{columns:i,rows:n}=a.tabularData;if(0===n.length)return{minTokens:0,maxTokens:0,avgTokens:0,sampleSize:0,calculated:new Date};const s=Math.min(n.length,10),o=n.slice(0,s),l=[];for(const r of o){let t=e.promptTemplate;for(const e of i){const a=String(r[e]||""),i=`{{${e}}}`;t=t.replace(new RegExp(i.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"g"),a)}const a=await this.countTokens(t);l.push(a)}return{minTokens:Math.min(...l),maxTokens:Math.max(...l),avgTokens:Math.round(l.reduce((e,t)=>e+t,0)/l.length),sampleSize:n.length,calculated:new Date,isAccurate:!1}}catch(t){return a.error("Failed to calculate aligned design tokens",t),{minTokens:0,maxTokens:0,avgTokens:0,sampleSize:0,calculated:new Date}}}clearCache(){this.tokenCountCache.clear()}};export{o as p,u as t};
