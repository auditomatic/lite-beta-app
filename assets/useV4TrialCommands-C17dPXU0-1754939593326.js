var re=Object.defineProperty;var ae=(l,e,t)=>e in l?re(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var v=(l,e,t)=>ae(l,typeof e!="symbol"?e+"":e,t);import{b as z,I as H,Z as se,$ as ie,a0 as ne,a1 as W,a as r,s as L,c as O,n as U,o as q,a2 as oe,l as j,d as o,a3 as M,h as X,a4 as Q,g as $,a5 as le,a6 as F,a7 as D,a8 as ue,a9 as ce,p as k,r as N}from"./index-BMvx8pDm-1754939593326.js";var de={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M516 673c0 4.4 3.4 8 7.5 8h185c4.1 0 7.5-3.6 7.5-8v-48c0-4.4-3.4-8-7.5-8h-185c-4.1 0-7.5 3.6-7.5 8v48zm-194.9 6.1l192-161c3.8-3.2 3.8-9.1 0-12.3l-192-160.9A7.95 7.95 0 00308 351v62.7c0 2.4 1 4.6 2.9 6.1L420.7 512l-109.8 92.2a8.1 8.1 0 00-2.9 6.1V673c0 6.8 7.9 10.5 13.1 6.1zM880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"}}]},name:"code",theme:"outlined"};function G(l){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?Object(arguments[e]):{},a=Object.keys(t);typeof Object.getOwnPropertySymbols=="function"&&(a=a.concat(Object.getOwnPropertySymbols(t).filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable}))),a.forEach(function(s){fe(l,s,t[s])})}return l}function fe(l,e,t){return e in l?Object.defineProperty(l,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):l[e]=t,l}var Y=function(e,t){var a=G({},e,t.attrs);return z(H,G({},a,{icon:de}),null)};Y.displayName="CodeOutlined";Y.inheritAttrs=!1;var pe={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM514.1 580.1l-61.8-102.4c-2.2-3.6-6.1-5.8-10.3-5.8h-38.4c-2.3 0-4.5.6-6.4 1.9-5.6 3.5-7.3 10.9-3.7 16.6l82.3 130.4-83.4 132.8a12.04 12.04 0 0010.2 18.4h34.5c4.2 0 8-2.2 10.2-5.7L510 664.8l62.3 101.4c2.2 3.6 6.1 5.7 10.2 5.7H620c2.3 0 4.5-.7 6.5-1.9 5.6-3.6 7.2-11 3.6-16.6l-84-130.4 85.3-132.5a12.04 12.04 0 00-10.1-18.5h-35.7c-4.2 0-8.1 2.2-10.3 5.8l-61.2 102.3z"}}]},name:"file-excel",theme:"outlined"};function B(l){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?Object(arguments[e]):{},a=Object.keys(t);typeof Object.getOwnPropertySymbols=="function"&&(a=a.concat(Object.getOwnPropertySymbols(t).filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable}))),a.forEach(function(s){he(l,s,t[s])})}return l}function he(l,e,t){return e in l?Object.defineProperty(l,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):l[e]=t,l}var Z=function(e,t){var a=B({},e,t.attrs);return z(H,B({},a,{icon:pe}),null)};Z.displayName="FileExcelOutlined";Z.inheritAttrs=!1;var J=function(l){se(e,l);function e(t,a,s){t===void 0&&(t=1/0),a===void 0&&(a=1/0),s===void 0&&(s=ie);var i=l.call(this)||this;return i._bufferSize=t,i._windowTime=a,i._timestampProvider=s,i._buffer=[],i._infiniteTimeWindow=!0,i._infiniteTimeWindow=a===1/0,i._bufferSize=Math.max(1,t),i._windowTime=Math.max(1,a),i}return e.prototype.next=function(t){var a=this,s=a.isStopped,i=a._buffer,n=a._infiniteTimeWindow,m=a._timestampProvider,h=a._windowTime;s||(i.push(t),!n&&i.push(m.now()+h)),this._trimBuffer(),l.prototype.next.call(this,t)},e.prototype._subscribe=function(t){this._throwIfClosed(),this._trimBuffer();for(var a=this._innerSubscribe(t),s=this,i=s._infiniteTimeWindow,n=s._buffer,m=n.slice(),h=0;h<m.length&&!t.closed;h+=i?1:2)t.next(m[h]);return this._checkFinalizedStatuses(t),a},e.prototype._trimBuffer=function(){var t=this,a=t._bufferSize,s=t._timestampProvider,i=t._buffer,n=t._infiniteTimeWindow,m=(n?1:2)*a;if(a<1/0&&m<i.length&&i.splice(0,i.length-m),!n){for(var h=s.now(),f=0,d=1;d<i.length&&i[d]<=h;d+=2)f=d;f&&i.splice(0,f+1)}},e}(ne);function me(l,e,t){var a,s,i,n,m=!1;return l&&typeof l=="object"?(a=l.bufferSize,n=a===void 0?1/0:a,s=l.windowTime,e=s===void 0?1/0:s,i=l.refCount,m=i===void 0?!1:i,t=l.scheduler):n=l??1/0,W({connector:function(){return new J(n,e,t)},resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:m})}function Oe(){const l=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials() composable ENTRY at ${l}`);const e=L([]),t=L(!0),a=L(null);let s=null;const i=O(()=>e.value),n=()=>{const E=performance.now();r.info(`V4_TRIAL_SWITCH: setupLiveQuery() ENTRY at ${E}`),s&&(s.unsubscribe(),s=null);const c=j(async()=>{try{return(await o.trials.orderBy("created").reverse().toArray()).filter(A=>!M(A)).map(A=>Object.freeze({...A,created:A.created instanceof Date?A.created:new Date(A.created),started:A.started?A.started instanceof Date?A.started:new Date(A.started):void 0,completed:A.completed?A.completed instanceof Date?A.completed:new Date(A.completed):void 0}))}catch(u){throw r.error("V4_TRIALS: Failed to load trials:",u),u}});s=X(c).subscribe({next:u=>{e.value=u,t.value=!1,a.value=null,r.info(`V4_TRIALS_DB: Loaded ${u.length} trials from database`)},error:u=>{r.error("V4_TRIALS: Query error:",u),a.value=u instanceof Error?u:new Error("Failed to load trials"),t.value=!1}})},m=O(()=>i.value.filter(E=>E.status==="running")),h=O(()=>i.value.filter(E=>E.status==="draft")),f=O(()=>i.value.filter(E=>E.status==="completed")),d=O(()=>i.value.filter(E=>E.status==="paused")),T=O(()=>i.value.filter(E=>E.status==="failed")),p=O(()=>i.value.length),_=O(()=>{const E={total:i.value.length,byStatus:{draft:0,pending:0,running:0,paused:0,completed:0,cancelled:0,failed:0},totalApiCalls:0,completedApiCalls:0,failedApiCalls:0,averageCompletionRate:0};for(const c of i.value)E.byStatus[c.status]++,c.progress&&(E.totalApiCalls+=c.progress.total,E.completedApiCalls+=c.progress.completed,E.failedApiCalls+=c.progress.failed);return E.totalApiCalls>0&&(E.averageCompletionRate=E.completedApiCalls/E.totalApiCalls*100),E}),R=async()=>{t.value=!0,a.value=null;try{const u=(await o.trials.orderBy("created").reverse().toArray()).filter(C=>!M(C)).map(C=>Object.freeze({...C,created:C.created instanceof Date?C.created:new Date(C.created),started:C.started?C.started instanceof Date?C.started:new Date(C.started):void 0,completed:C.completed?C.completed instanceof Date?C.completed:new Date(C.completed):void 0}));e.value=u,t.value=!1,r.info(`V4_TRIALS: Manual refresh loaded ${u.length} trials`)}catch(E){r.error("V4_TRIALS: Refresh failed:",E),a.value=E instanceof Error?E:new Error("Failed to refresh trials"),t.value=!1}};return U(()=>{const E=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials onMounted() ENTRY at ${E}`),r.info("V4_TRIALS: Mounting trials query composable");const c=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials calling setupLiveQuery() at ${(c-E).toFixed(1)}ms`),n();const u=performance.now();r.info(`V4_TRIAL_SWITCH: useV4Trials setupLiveQuery() completed in ${(u-c).toFixed(1)}ms`)}),q(()=>{r.info("V4_TRIALS: Unmounting trials query composable"),s&&(s.unsubscribe(),s=null)}),{trials:i,loading:t,error:a,runningTrials:m,draftTrials:h,completedTrials:f,pausedTrials:d,failedTrials:T,totalTrials:p,statistics:_,refresh:R}}function be(l){const e=L(null),t=L(!0),a=L(null);let s=null,i=null;const n=O(()=>(typeof l=="object"&&l!==null?l.value:l)?e.value:null),m=f=>{const d=performance.now();if(r.info(`V4_TRIAL_SWITCH: Single trial query setup for ${f}`),s&&(s.unsubscribe(),s=null),!f){e.value=null,t.value=!1,r.info("V4_TRIAL_SWITCH: Single trial query cleared (no ID)");return}const T=j(async()=>{const p=performance.now();r.info(`V4_TRIAL_SWITCH: Single trial DB query starting at ${(p-d).toFixed(1)}ms`);const _=await o.trials.get(f),R=performance.now();return r.info(`V4_TRIAL_SWITCH: Single trial DB query completed in ${(R-p).toFixed(1)}ms`),_?Object.freeze({..._,created:_.created instanceof Date?_.created:new Date(_.created),started:_.started?_.started instanceof Date?_.started:new Date(_.started):void 0,completed:_.completed?_.completed instanceof Date?_.completed:new Date(_.completed):void 0}):null});s=X(T).subscribe({next:p=>{const _=performance.now();e.value=p,t.value=!1,a.value=null,p&&r.info(`V4_TRIAL_SWITCH: Trial ${p.id} loaded from database in ${(_-d).toFixed(1)}ms`)},error:p=>{r.error("V4_TRIALS: Single trial query error:",p),a.value=p instanceof Error?p:new Error("Failed to load trial"),t.value=!1}})},h=async()=>{const f=typeof l=="object"&&l!==null?l.value:l;if(!f){e.value=null,t.value=!1;return}t.value=!0,a.value=null;try{const d=await o.trials.get(f);d?e.value=Object.freeze({...d,created:d.created instanceof Date?d.created:new Date(d.created),started:d.started?d.started instanceof Date?d.started:new Date(d.started):void 0,completed:d.completed?d.completed instanceof Date?d.completed:new Date(d.completed):void 0}):e.value=null,t.value=!1}catch(d){r.error("V4_TRIALS: Refresh single trial failed:",d),a.value=d instanceof Error?d:new Error("Failed to refresh trial"),t.value=!1}};return typeof l=="object"&&l!==null?U(()=>{r.info("V4_TRIALS: Mounting single trial query with reactive ID"),i=oe(()=>{const f=l.value;r.info("V4_TRIALS: Trial ID changed to:",f),m(f)})}):U(()=>{r.info("V4_TRIALS: Mounting single trial query for static ID:",l),m(l)}),q(()=>{r.info("V4_TRIALS: Unmounting single trial query"),s&&(s.unsubscribe(),s=null),i&&(i(),i=null)}),{trial:n,loading:t,error:a,refresh:h}}class Te{constructor(){v(this,"state",Q({status:"idle",trialId:null,orchestratorType:null,startedAt:null,pausedAt:null,completedAt:null,tabId:null}));v(this,"currentState",O(()=>({...this.state})));v(this,"status",O(()=>this.state.status));v(this,"trialId",O(()=>this.state.trialId));v(this,"orchestratorType",O(()=>this.state.orchestratorType));v(this,"isExecuting",O(()=>["starting","running","pausing"].includes(this.state.status)));v(this,"isPaused",O(()=>this.state.status==="paused"));v(this,"isIdle",O(()=>this.state.status==="idle"))}async hydrate(){r.info("STATE_MACHINE: Hydrating state from database...");const e=await o.trials.where("status").equals("running").toArray();if(e.length>0){r.info(`STATE_MACHINE: Found ${e.length} running trials, marking as paused (page refreshed)`);for(const t of e)await o.trials.update(t.id,{status:"paused"}),r.info(`STATE_MACHINE: Paused trial ${t.id} (was running, page refreshed)`)}r.info("STATE_MACHINE: State machine starting idle - use resume to continue paused trials")}async startExecution(e,t,a){if(r.info(`STATE_MACHINE: Starting execution - trial=${e}, orchestrator=${t}, tab=${a}`),this.state.status!=="idle"&&this.state.status!=="paused")return{ok:!1,error:new Error(`Cannot start: current status is ${this.state.status}`)};try{return this.state.status="starting",this.state.trialId=e,this.state.orchestratorType=t,this.state.tabId=a,this.state.startedAt=new Date,this.state.pausedAt=null,this.state.completedAt=null,await o.trials.update(e,{status:"running",started:this.state.startedAt}),this.state.status="running",r.info(`STATE_MACHINE: Successfully started execution for trial ${e}`),{ok:!0,value:void 0}}catch(s){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,{ok:!1,error:s instanceof Error?s:new Error("Failed to start execution")}}}async pauseExecution(){if(r.info(`STATE_MACHINE: Pausing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot pause: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot pause: no active trial")};try{return this.state.status="pausing",this.state.pausedAt=new Date,await o.trials.update(this.state.trialId,{status:"paused"}),this.state.status="paused",r.info(`STATE_MACHINE: Successfully paused execution for trial ${this.state.trialId}`),{ok:!0,value:void 0}}catch(e){return this.state.status="running",this.state.pausedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to pause execution")}}}async resumeExecution(e,t){if(r.info(`STATE_MACHINE: Resuming trial ${e} - current status=${this.state.status}, tab=${t}`),!["idle","paused"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot resume: current status is ${this.state.status}`)};try{const a=await o.trials.get(e);if(!a)return{ok:!1,error:new Error(`Trial ${e} not found`)};if(a.status!=="paused")return{ok:!1,error:new Error(`Cannot resume: trial status is ${a.status}, expected paused`)};const s=a.type==="playground"?"streaming":"regular";return this.state.status="running",this.state.trialId=e,this.state.orchestratorType=s,this.state.tabId=t,this.state.startedAt=a.started||new Date,this.state.pausedAt=null,this.state.completedAt=null,await o.trials.update(e,{status:"running"}),r.info(`STATE_MACHINE: Successfully resumed execution for trial ${e}`),{ok:!0,value:void 0}}catch(a){return this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,{ok:!1,error:a instanceof Error?a:new Error("Failed to resume execution")}}}async cancelExecution(){if(r.info(`STATE_MACHINE: Cancelling execution - current status=${this.state.status}`),!["running","paused","starting"].includes(this.state.status))return{ok:!1,error:new Error(`Cannot cancel: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot cancel: no active trial")};try{const e=this.state.trialId;return this.state.status="cancelling",this.state.completedAt=new Date,await o.trials.update(e,{status:"cancelled",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.info(`STATE_MACHINE: Successfully cancelled execution for trial ${e}`),{ok:!0,value:void 0}}catch(e){return this.state.status=this.state.pausedAt?"paused":"running",this.state.completedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to cancel execution")}}}async completeExecution(){if(r.info(`STATE_MACHINE: Completing execution - current status=${this.state.status}`),this.state.status!=="running")return{ok:!1,error:new Error(`Cannot complete: current status is ${this.state.status}`)};if(!this.state.trialId)return{ok:!1,error:new Error("Cannot complete: no active trial")};try{const e=this.state.trialId;return this.state.status="completed",this.state.completedAt=new Date,await o.trials.update(e,{status:"completed",completed:this.state.completedAt}),this.state.status="idle",this.state.trialId=null,this.state.orchestratorType=null,this.state.tabId=null,this.state.startedAt=null,this.state.pausedAt=null,r.info(`STATE_MACHINE: Successfully completed execution for trial ${e}`),{ok:!0,value:void 0}}catch(e){return this.state.status="running",this.state.completedAt=null,{ok:!1,error:e instanceof Error?e:new Error("Failed to complete execution")}}}canStart(){return this.state.status==="idle"||this.state.status==="paused"}canPause(){return this.state.status==="running"}canResume(){return this.state.status==="paused"&&this.state.orchestratorType!==null}canCancel(){return["running","paused","starting"].includes(this.state.status)}isOwnedByTab(e){return this.state.tabId===e}}const g=new Te;class _e{constructor(){v(this,"state",Q({tabId:$("tab"),role:"observer",isInitialized:!1,lastHeartbeat:new Date}));v(this,"broadcastChannel",null);v(this,"lockReleaseFunction",null);v(this,"heartbeatInterval",null);v(this,"tabId",O(()=>this.state.tabId));v(this,"role",O(()=>this.state.role));v(this,"isLeader",O(()=>this.state.role==="leader"));v(this,"isObserver",O(()=>this.state.role==="observer"));v(this,"isInitialized",O(()=>this.state.isInitialized))}async initialize(){if(this.state.isInitialized){r.info(`COORDINATION: Tab ${this.state.tabId} already initialized as ${this.state.role}`);return}r.info(`COORDINATION: Initializing tab ${this.state.tabId}`);try{this.broadcastChannel=new BroadcastChannel("auditomatic-coordination"),this.broadcastChannel.onmessage=e=>{this.handleCoordinationMessage(e.data)},await this.attemptLeadershipAcquisition(),this.startHeartbeat(),this.state.isInitialized=!0,r.info(`COORDINATION: Tab ${this.state.tabId} initialized as ${this.state.role}`)}catch(e){throw r.error(`COORDINATION: Failed to initialize tab ${this.state.tabId}:`,e),e}}async attemptLeadershipAcquisition(){if(!("locks"in navigator)){r.info(`COORDINATION: Web Locks not available, tab ${this.state.tabId} becomes leader`),this.state.role="leader";return}try{r.info(`COORDINATION: Tab ${this.state.tabId} attempting to acquire leadership lock`),navigator.locks.request("auditomatic-leader",{mode:"exclusive",ifAvailable:!0},e=>{if(e)return r.info(`COORDINATION: Tab ${this.state.tabId} acquired leadership lock`),this.state.role="leader",new Promise(t=>{this.lockReleaseFunction=t});r.info(`COORDINATION: Tab ${this.state.tabId} could not acquire lock - observer mode`),this.state.role="observer"}),await new Promise(e=>setTimeout(e,50))}catch(e){r.error(`COORDINATION: Leadership acquisition failed for tab ${this.state.tabId}:`,e),this.state.role="observer"}}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.state.lastHeartbeat=new Date,this.broadcast({type:"heartbeat",tabId:this.state.tabId,timestamp:this.state.lastHeartbeat})},1e4)}broadcast(e){this.broadcastChannel&&(r.info(`COORDINATION: Broadcasting ${e.type} from tab ${this.state.tabId}`),this.broadcastChannel.postMessage(e))}handleCoordinationMessage(e){if(e.tabId!==this.state.tabId)switch(r.info(`COORDINATION: Tab ${this.state.tabId} received ${e.type} from ${e.tabId}`),e.type){case"execution:started":this.state.role==="observer"&&e.trialId&&r.info(`COORDINATION: Observer tab syncing to started execution: ${e.trialId}`);break;case"execution:paused":this.state.role==="observer"&&e.trialId&&r.info(`COORDINATION: Observer tab syncing to paused execution: ${e.trialId}`);break;case"execution:resumed":this.state.role==="observer"&&e.trialId&&r.info(`COORDINATION: Observer tab syncing to resumed execution: ${e.trialId}`);break;case"execution:cancelled":case"execution:completed":this.state.role==="observer"&&e.trialId&&r.info(`COORDINATION: Observer tab syncing to ended execution: ${e.trialId}`);break;case"heartbeat":r.info(`COORDINATION: Heartbeat from ${e.tabId}`);break}}canExecuteActions(){return this.state.role==="leader"}validateLeadership(e){return this.state.role!=="leader"?{ok:!1,error:new Error(`Cannot ${e}: only leader tab can execute actions`)}:{ok:!0,value:void 0}}async startExecution(e,t){const a=this.validateLeadership("start execution");if(!a.ok)return a;r.info(`COORDINATION: Leader starting execution - trial=${e}, orchestrator=${t}`);const s=await g.startExecution(e,t,this.state.tabId);return s.ok&&this.broadcast({type:"execution:started",tabId:this.state.tabId,timestamp:new Date,trialId:e,orchestratorType:t}),s}async pauseExecution(){const e=this.validateLeadership("pause execution");if(!e.ok)return e;r.info("COORDINATION: Leader pausing execution");const t=await g.pauseExecution();return t.ok&&this.broadcast({type:"execution:paused",tabId:this.state.tabId,timestamp:new Date,trialId:g.trialId.value||void 0}),t}async resumeExecution(e){const t=this.validateLeadership("resume execution");if(!t.ok)return t;r.info(`COORDINATION: Leader resuming execution for trial ${e}`);const a=await g.resumeExecution(e,this.state.tabId);return a.ok&&this.broadcast({type:"execution:resumed",tabId:this.state.tabId,timestamp:new Date,trialId:e}),a}async cancelExecution(){const e=this.validateLeadership("cancel execution");if(!e.ok)return e;r.info("COORDINATION: Leader cancelling execution");const t=g.trialId.value,a=await g.cancelExecution();return a.ok&&this.broadcast({type:"execution:cancelled",tabId:this.state.tabId,timestamp:new Date,trialId:t||void 0}),a}async completeExecution(){const e=this.validateLeadership("complete execution");if(!e.ok)return e;r.info("COORDINATION: Leader completing execution");const t=g.trialId.value,a=await g.completeExecution();return a.ok&&this.broadcast({type:"execution:completed",tabId:this.state.tabId,timestamp:new Date,trialId:t||void 0}),a}destroy(){r.info(`COORDINATION: Destroying tab ${this.state.tabId}`),this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.lockReleaseFunction&&(this.lockReleaseFunction(),this.lockReleaseFunction=null),this.broadcastChannel&&(this.broadcastChannel.close(),this.broadcastChannel=null),this.state.isInitialized=!1,r.info(`COORDINATION: Tab ${this.state.tabId} cleanup complete`)}}const w=new _e;class Ee{async updateTrial(e){r.info(`ATOMIC_OPS: Updating trial ${e.trialId} - status=${e.status}`);try{const t={};return e.status!==void 0&&(t.status=e.status),e.started!==void 0&&(t.started=e.started),e.completed!==void 0&&(t.completed=e.completed),e.progress!==void 0&&(t.progress=e.progress),await o.trials.update(e.trialId,t),r.info(`ATOMIC_OPS: Successfully updated trial ${e.trialId}`),{ok:!0,value:void 0}}catch(t){return r.error(`ATOMIC_OPS: Failed to update trial ${e.trialId}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update trial")}}}async resetRunningCallsToPending(e){r.info(`ATOMIC_OPS: Resetting running calls to pending for trial ${e}`);try{const t=await o.apiCalls.where("trialId").equals(e).and(a=>a.status==="running").toArray();return t.length===0?r.info(`ATOMIC_OPS: No running calls found for trial ${e}`):(await o.transaction("rw",o.apiCalls,async()=>{for(const a of t)await o.apiCalls.update(a.id,{status:"pending",started:void 0,response:void 0,result:void 0})}),r.info(`ATOMIC_OPS: Reset ${t.length} running calls to pending for trial ${e}`)),r.info("V4_TRIAL_DEBUG_PAUSE: Recalculating trial progress after call status changes"),await this.recalculateTrialProgress(e),{ok:!0,value:t.length}}catch(t){return r.error(`ATOMIC_OPS: Failed to reset running calls for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to reset running calls")}}}async getTrialCallCounts(e){r.info(`ATOMIC_OPS: Getting call counts for trial ${e}`);try{const t=await o.transaction("r",o.apiCalls,async()=>{const a=await o.apiCalls.where("trialId").equals(e).toArray();return{total:a.length,completed:a.filter(s=>s.status==="completed").length,failed:a.filter(s=>s.status==="failed").length,cancelled:a.filter(s=>s.status==="cancelled").length,pending:a.filter(s=>s.status==="pending").length,running:a.filter(s=>s.status==="running").length}});return r.info(`TRANSACTION_FIX: Trial ${e} call counts (consistent snapshot):`,t),{ok:!0,value:t}}catch(t){return r.error(`ATOMIC_OPS: Failed to get call counts for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to get call counts")}}}async updateApiCallsBatch(e){if(e.length===0)return{ok:!0,value:void 0};r.info(`ATOMIC_OPS: Updating batch of ${e.length} API calls`);try{return await o.transaction("rw",o.apiCalls,async()=>{for(const t of e){const a={status:t.status};t.started!==void 0&&(a.started=t.started),t.completed!==void 0&&(a.completed=t.completed),t.response!==void 0&&(a.response=t.response),t.error!==void 0&&(a.error=t.error),await o.apiCalls.update(t.callId,a)}}),r.info(`ATOMIC_OPS: Successfully updated batch of ${e.length} API calls`),{ok:!0,value:void 0}}catch(t){return r.error("ATOMIC_OPS: Failed to update API calls batch:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update API calls batch")}}}async reconcileTrialState(e){r.info(`ATOMIC_OPS: Reconciling state for trial ${e}`);try{const t=await o.trials.get(e);if(!t)return{ok:!1,error:new Error(`Trial ${e} not found`)};const a=await this.getTrialCallCounts(e);if(!a.ok)return a;const s=a.value;let i=t.status;if(s.running>0?i="running":s.pending>0?i="paused":s.completed===s.total&&s.total>0||s.failed>0&&s.completed+s.failed===s.total?i="completed":s.cancelled>0&&(i="cancelled"),i!==t.status){r.info(`ATOMIC_OPS: Reconciling trial ${e} status: ${t.status} â†’ ${i}`);const n=await this.updateTrial({trialId:e,status:i,progress:s,...i==="completed"&&{completed:new Date}});if(!n.ok)return n}else r.info(`ATOMIC_OPS: Trial ${e} status is consistent: ${i}`);return{ok:!0,value:i}}catch(t){return r.error(`ATOMIC_OPS: Failed to reconcile trial ${e} state:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to reconcile trial state")}}}async performCleanupOperations(e){r.info(`ATOMIC_OPS: Performing cleanup operations for trial ${e}`);try{const t=await this.resetRunningCallsToPending(e);if(!t.ok)return t;const a=await this.reconcileTrialState(e);if(!a.ok)return a;const s={resetCount:t.value,reconciledStatus:a.value};return r.info(`ATOMIC_OPS: Cleanup complete for trial ${e}:`,s),{ok:!0,value:s}}catch(t){return r.error(`ATOMIC_OPS: Failed cleanup operations for trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed cleanup operations")}}}async recalculateTrialProgress(e){var t;try{const a=await o.trials.get(e);if(!a){r.info(`V4_TRIAL_DEBUG_PAUSE: Trial ${e} not found, cannot recalculate progress`);return}const s=await o.apiCalls.where("trialId").equals(e).toArray();let i=0,n=0,m=0,h=0,f=0;for(const p of s)switch(p.status){case"completed":i++;break;case"failed":n++,((t=p.result)==null?void 0:t.errorType)==="network_error_no_response"&&f++;break;case"cancelled":m++;break;case"running":h++;break}const d=a.progress.total-i-n-m-h,T={total:a.progress.total,completed:i,failed:n,cancelled:m,pending:d,running:h,networkErrors:f};r.info(`V4_TRIAL_DEBUG_PAUSE: Recalculated progress for trial ${e} - completed: ${i}, failed: ${n}, running: ${h}, pending: ${d}`),await o.trials.update(e,{progress:T}),r.info("V4_TRIAL_DEBUG_PAUSE: Trial progress updated successfully")}catch(a){r.error(`V4_TRIAL_DEBUG_PAUSE: Failed to recalculate progress for trial ${e}:`,a)}}async performSystemCleanup(){r.info("ATOMIC_OPS: Performing system-wide cleanup");try{let e=0,t=0;const a=await o.trials.where("status").equals("running").toArray();r.info(`ATOMIC_OPS: Found ${a.length} active trials for cleanup`);for(const i of a){const n=await this.performCleanupOperations(i.id);if(n.ok)e+=n.value.resetCount,t++;else{const m=n;r.warn(`ATOMIC_OPS: Failed to cleanup trial ${i.id}:`,m.error.message)}}const s={trialsProcessed:t,callsReset:e};return r.info("ATOMIC_OPS: System cleanup complete:",s),{ok:!0,value:s}}catch(e){return r.error("ATOMIC_OPS: System cleanup failed:",e),{ok:!1,error:e instanceof Error?e:new Error("System cleanup failed")}}}}const Ce=new Ee;class ge{constructor(){v(this,"playgroundService",null);v(this,"initialized",!1);v(this,"orchestrators",new Map);v(this,"activeStreams",new Map);v(this,"execution",O(()=>{const e=g.status.value;let t="idle";return e==="running"||e==="starting"||e==="pausing"?t="executing":e==="paused"?t="paused":t="idle",{status:t,currentTrialId:g.trialId.value,startedAt:g.currentState.value.startedAt}}));v(this,"progress",O(()=>({trials:new Map,activeApiCall:null,lastUpdated:new Date})));v(this,"queue",O(()=>({global:{pending:0,executing:0,capacity:0,utilization:0},providers:new Map})));v(this,"tabRole",O(()=>w.role.value));v(this,"isLeader",O(()=>w.isLeader.value));v(this,"canExecute",O(()=>w.isLeader.value&&g.canStart()))}async initialize(){const e=performance.now();if(r.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialize() ENTRY at ${e}`),r.info(`V4_SINGLETON_DEBUG: Current initialized flag: ${this.initialized}`),r.info(`V4_SINGLETON_DEBUG: Active streams count: ${this.activeStreams.size}`),this.initialized){r.info("V4_SINGLETON_DEBUG: V4ExecutionControl already initialized, returning early - singleton working correctly!");return}try{r.info("V4_EXECUTION_CONTROL: Initializing with V4 coordination + V3 execution bridge");const t=performance.now();r.info(`V4_TRIAL_SWITCH: Starting multiTabCoordinator.initialize() at ${(t-e).toFixed(1)}ms`),await w.initialize();const a=performance.now();r.info(`V4_TRIAL_SWITCH: multiTabCoordinator.initialize() completed in ${(a-t).toFixed(1)}ms`),r.info("V4_EXECUTION_CONTROL: Performing system cleanup with V4 atomic operations");const s=performance.now();r.info(`V4_TRIAL_SWITCH: Starting atomicOperations.performSystemCleanup() at ${(s-e).toFixed(1)}ms`);const i=await Ce.performSystemCleanup(),n=performance.now();if(r.info(`V4_TRIAL_SWITCH: atomicOperations.performSystemCleanup() completed in ${(n-s).toFixed(1)}ms`),i.ok)r.info("V4_EXECUTION_CONTROL: System cleanup completed:",i.value);else{const d=i;r.warn("V4_EXECUTION_CONTROL: System cleanup failed:",d.error)}const m=performance.now();r.info(`V4_TRIAL_SWITCH: Creating PlaygroundExecutionService at ${(m-e).toFixed(1)}ms`),this.playgroundService=new le(async d=>{const T=await this.startTrialWithStreaming(d);return T.ok?{ok:!0,value:T.value.progress$}:T});const h=performance.now();r.info(`V4_TRIAL_SWITCH: PlaygroundExecutionService created in ${(h-m).toFixed(1)}ms`),this.initialized=!0;const f=performance.now();r.info(`V4_TRIAL_SWITCH: V4ExecutionControl initialization TOTAL: ${(f-e).toFixed(1)}ms`),r.info("V4_EXECUTION_CONTROL: Initialization complete")}catch(t){const a=performance.now();throw r.error(`V4_TRIAL_SWITCH: V4ExecutionControl initialization FAILED in ${(a-e).toFixed(1)}ms:`,t),t}}cleanup(){r.info("V4_SINGLETON_DEBUG: cleanup() called - this will reset initialized flag and destroy singleton!"),r.info(`V4_SINGLETON_DEBUG: Current active streams: ${this.activeStreams.size}`),r.info(`V4_SINGLETON_DEBUG: Current orchestrators: ${this.orchestrators.size}`);try{this.activeStreams.forEach((e,t)=>{r.info(`V4_SINGLETON_DEBUG: Cleaning up streams for trial ${t}`),e.subscription.unsubscribe()}),this.activeStreams.clear(),this.orchestrators.forEach((e,t)=>{r.info(`V4_SINGLETON_DEBUG: Cleaning up orchestrator for trial ${t}`)}),this.orchestrators.clear(),w.destroy(),this.playgroundService=null,this.initialized=!1,r.info("V4_SINGLETON_DEBUG: Cleanup complete - singleton destroyed, will reinitialize on next call")}catch(e){r.error("V4_EXECUTION_CONTROL: Cleanup error:",e)}}async startTrial(e){var t;this.initialized||await this.initialize(),r.info(`V4_EXECUTION_CONTROL: Starting trial ${e} with V4+V3 bridge`);try{if(F(e)){const m=await(((t=this.playgroundService)==null?void 0:t.executePlaygroundCall("",{}))||Promise.resolve({ok:!1,error:new Error("Playground service not available")}));return m.ok?{ok:!0,value:void 0}:{ok:!1,error:m.error}}let s=this.orchestrators.get(e);s||(r.info("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",e),s=D(),this.orchestrators.set(e,s));const n=await s.startTrialAtomic(e);return n.ok?(r.info(`V4_EXECUTION_CONTROL: Successfully started trial ${e} via bridge`),{ok:!0,value:void 0}):{ok:!1,error:n.error}}catch(a){return r.error(`V4_EXECUTION_CONTROL: Failed to start trial ${e}:`,a),{ok:!1,error:a instanceof Error?a:new Error("Failed to start trial")}}}async startTrialWithStreaming(e){this.initialized||await this.initialize(),r.info(`V4_EXECUTION_CONTROL: Starting streaming trial ${e}`),this.cleanupStreams(e);try{if(F(e))return r.info("V4_EXECUTION_CONTROL: Playground trial detected, using specialized handling"),{ok:!1,error:new Error("Playground streaming not yet implemented in V4")};if(!this.canExecute.value)return r.info("V4_EXECUTION_CONTROL: Cannot start - not leader or invalid state"),{ok:!1,error:new Error("Cannot start trial - not leader or invalid state")};r.info("V4_EXECUTION_CONTROL: Updating state machine to running");const a=w.tabId.value,s=await g.startExecution(e,"streaming",a);if(!s.ok)return r.info("V4_EXECUTION_CONTROL: State machine update failed:",s.error),{ok:!1,error:s.error};let i=this.orchestrators.get(e);i||(r.info("V4_EXECUTION_CONTROL: Creating fresh V3 orchestrator for trial:",e),i=D(),this.orchestrators.set(e,i)),r.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator startTrialAtomicWithStreaming");const n=await i.startTrialAtomicWithStreaming(e);if(!n.ok)return{ok:!1,error:n.error};r.info("V4_EXECUTION_CONTROL: Creating hot observables without accumulation"),r.info(`V4_EXECUTION_CONTROL: Creating hot observables for trial ${e}`);const m=n.value.progress$.pipe(W(),me({bufferSize:1,refCount:!0})),h=new ue,f=new J(1),d=n.value.calls$.pipe(ce(p=>(r.info(`V4_EXECUTION_CONTROL: Batch of ${p.length} calls from pipeline`),p.map(_=>_.call&&_.providerId?_.call:_)))).subscribe({next:p=>{r.info(`V4_EXECUTION_CONTROL: Forwarding ${p.length} calls to subject`),f.next(p)},error:p=>{r.info("V4_TRIAL_ERROR: Error in calls stream:",p),f.error(p)},complete:()=>{r.info(`V4_TRIAL_COMPLETE: Original calls stream completed for trial ${e}`)}});h.add(d);const T=f;return r.info("V4_TRIAL_REF_TEST: callsSubject === sharedCalls$?",f===T),h.add(m.subscribe({next:p=>{r.info(`V4_TRIAL_DEBUG_COMPLETION: Progress update for trial ${e}: ${p.type}`),(p.type==="completed"||p.type==="error")&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Trial ${e} ${p.type}, scheduling cleanup in 1000ms`),r.info(`V4_TRIAL_DEBUG_COMPLETION: Current execution state: ${g.status.value}`),r.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to completed/cancelled state"),p.type==="completed"?(r.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.completeExecution()"),w.completeExecution().then(_=>{_.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to completed successfully"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${g.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer completion update failed:",_.error)})):(r.info("V4_TRIAL_DEBUG_COMPLETION: Calling multiTabCoordinator.cancelExecution() for error"),w.cancelExecution().then(_=>{_.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled successfully"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-cancellation execution state: ${g.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer cancellation update failed:",_.error)})),setTimeout(()=>{r.info(`V4_TRIAL_DEBUG_COMPLETION: Executing delayed cleanup for trial ${e}`),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-completion execution state: ${g.status.value}`),this.cleanupStreams(e),this.orchestrators.has(e)&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for completed trial ${e}`),this.orchestrators.delete(e))},1e3))},error:p=>{r.error(`V4_TRIAL_DEBUG_COMPLETION: Stream error for trial ${e}:`,p),r.info("V4_TRIAL_DEBUG_COMPLETION: Updating V4 coordination layer to cancelled state due to error"),w.cancelExecution().then(_=>{_.ok?(r.info("V4_TRIAL_DEBUG_COMPLETION: Coordination layer updated to cancelled after error"),r.info(`V4_TRIAL_DEBUG_COMPLETION: Post-error execution state: ${g.status.value}`)):r.error("V4_TRIAL_DEBUG_COMPLETION: Coordination layer error cancellation failed:",_.error)}),this.cleanupStreams(e),this.orchestrators.has(e)&&(r.info(`V4_TRIAL_DEBUG_COMPLETION: Removing orchestrator for errored trial ${e}`),this.orchestrators.delete(e))}})),r.info(`V4_TRIAL_STORE: Storing activeStreams for trial ${e}`),this.activeStreams.set(e,{streams:n.value,subscription:h,sharedProgress$:m,sharedCalls$:T,callsSubject:f}),r.info(`V4_EXECUTION_CONTROL: Successfully created hot observables for trial ${e}`),{ok:!0,value:n.value}}catch(t){return r.error(`V4_EXECUTION_CONTROL: Failed to start streaming trial ${e}:`,t),{ok:!1,error:t instanceof Error?t:new Error("Failed to start streaming trial")}}}async pauseExecution(){this.initialized||await this.initialize();const e=g.trialId.value;if(r.info(`V4_TRIAL_DEBUG_PAUSE: pauseExecution() ENTRY for trial ${e||"NONE"}`),r.info(`V4_TRIAL_DEBUG_PAUSE: Current execution state: ${g.status.value}`),r.info(`V4_TRIAL_DEBUG_PAUSE: Active streams count: ${this.activeStreams.size}`),!e)return r.info("V4_TRIAL_DEBUG_PAUSE: ERROR - No active trial to pause"),{ok:!1,error:new Error("No active trial to pause")};if(!g.canPause())return r.info("V4_TRIAL_DEBUG_PAUSE: Cannot pause - invalid state"),{ok:!1,error:new Error("Cannot pause in current state")};r.info("V4_TRIAL_DEBUG_PAUSE: Updating state machine to paused");const t=await g.pauseExecution();if(!t.ok)return r.info("V4_TRIAL_DEBUG_PAUSE: State machine update failed:",t.error),t;r.info("V4_TRIAL_DEBUG_PAUSE: Calling V3 orchestrator pauseTrial");const a=this.orchestrators.get(e);return a&&(await a.pauseTrial(),r.info("V4_TRIAL_DEBUG_PAUSE: Keeping orchestrator alive for potential hot resume")),w.pauseExecution(),r.info("V4_TRIAL_DEBUG_PAUSE: Pause successful"),{ok:!0,value:void 0}}async resumeExecution(e){this.initialized||await this.initialize();const t=e||g.trialId.value;if(r.info(`V4_TRIAL_DEBUG_RESUME: resumeExecution() ENTRY for trial ${t||"NONE"}`),r.info(`V4_TRIAL_DEBUG_RESUME: Current execution state: ${g.status.value}`),r.info(`V4_TRIAL_DEBUG_RESUME: Active streams count: ${this.activeStreams.size}`),r.info(`V4_TRIAL_DEBUG_RESUME: Provided trialId: ${e||"NONE"}, state trialId: ${g.trialId.value||"NONE"}`),!t)return r.info("V4_TRIAL_DEBUG_RESUME: ERROR - No trial ID provided and no active trial to resume"),{ok:!1,error:new Error("No trial ID provided and no active trial to resume")};if(!g.canResume())return r.info("V4_TRIAL_DEBUG_RESUME: Cannot resume - invalid state"),{ok:!1,error:new Error("Cannot resume in current state")};r.info("V4_TRIAL_DEBUG_RESUME: Updating state machine to running");const a=w.tabId.value,s=await g.resumeExecution(t,a);if(!s.ok)return r.info("V4_TRIAL_DEBUG_RESUME: State machine update failed:",s.error),s;let i=this.orchestrators.get(t);if(i)r.info(`V4_TRIAL_DEBUG_RESUME: HOT RESUME - Found existing orchestrator for trial ${t}`),r.info("V4_TRIAL_DEBUG_RESUME: Calling orchestrator.resumeTrial() to flip pause$ and resume pipeline"),i.resumeTrial();else{r.info(`V4_TRIAL_DEBUG_RESUME: COLD RESUME - No orchestrator found for trial ${t}`),r.info("V4_TRIAL_DEBUG_RESUME: Creating fresh orchestrator and starting with pending calls"),i=D(),this.orchestrators.set(t,i),r.info("V4_TRIAL_DEBUG_RESUME: Calling startTrialAtomicWithStreaming to create new pipeline");const n=await i.startTrialAtomicWithStreaming(t);if(!n.ok)return r.error("V4_TRIAL_DEBUG_RESUME: Failed to start trial for cold resume:",n.error),{ok:!1,error:n.error};r.info("V4_TRIAL_DEBUG_RESUME: Cold resume successful, storing new streams")}return w.resumeExecution(t),r.info("V4_TRIAL_DEBUG_RESUME: Resume successful"),{ok:!0,value:void 0}}async cancelExecution(){this.initialized||await this.initialize(),r.info("V4_EXECUTION_CONTROL: Cancelling execution");const e=g.trialId.value;if(!e)return{ok:!1,error:new Error("No active trial to cancel")};if(!g.canCancel())return r.info("V4_EXECUTION_CONTROL: Cannot cancel - invalid state"),{ok:!1,error:new Error("Cannot cancel in current state")};r.info("V4_EXECUTION_CONTROL: Updating state machine to cancelled");const t=await g.cancelExecution();if(!t.ok)return r.info("V4_EXECUTION_CONTROL: State machine update failed:",t.error),t;r.info("V4_EXECUTION_CONTROL: Calling V3 orchestrator cancelTrial");const a=this.orchestrators.get(e);return a&&(a.cancelTrial(),r.info("V4_EXECUTION_CONTROL: Removing orchestrator after cancel"),this.orchestrators.delete(e)),w.cancelExecution(),this.cleanupStreams(e),r.info("V4_EXECUTION_CONTROL: Cancel successful"),{ok:!0,value:void 0}}async executeSingleCall(e,t,a){return this.initialized||await this.initialize(),this.playgroundService?this.playgroundService.executePlaygroundCall(e,a):{ok:!1,error:new Error("Playground service not initialized")}}getActiveStreams(e){const t=this.activeStreams.get(e);return r.info(`V4_TRIAL_GET: getActiveStreams(${e}) called, found: ${!!t}, has sharedCalls$: ${!!(t!=null&&t.sharedCalls$)}`),t}cleanupStreams(e){r.info(`V4_TRIAL_DEBUG_CLEANUP: cleanupStreams() ENTRY for trial ${e}`),r.info(`V4_TRIAL_DEBUG_CLEANUP: Current execution state: ${g.status.value}`),r.info(`V4_TRIAL_DEBUG_CLEANUP: Current state trialId: ${g.trialId.value}`);const t=this.activeStreams.get(e);t?(r.info(`V4_TRIAL_DEBUG_CLEANUP: Found streams for trial ${e}, unsubscribing`),t.subscription.unsubscribe(),this.activeStreams.delete(e),r.info(`V4_TRIAL_DEBUG_CLEANUP: Cleaned up streams, remaining active streams: ${this.activeStreams.size}`)):r.info(`V4_TRIAL_DEBUG_CLEANUP: No streams found for trial ${e} (already cleaned up?)`)}}let x=null;function ye(){return x||(x=new ge),x}class Ie{async createTrial(e){try{const t=this.validateTrialConfig(e);if(!t.ok)return{ok:!1,error:t.error};const a=await this.createConfigurationSnapshots(e.configurations),s={id:$("trial"),name:e.name,description:e.description,type:e.type,status:"draft",configurations:a,progress:{total:0,completed:0,failed:0,cancelled:0,pending:0,running:0,networkErrors:0},created:new Date,...e.repeatCount&&e.repeatCount>1?{repeatConfig:{callsPerPrompt:e.repeatCount}}:{},...e.type==="template"&&e.templateConfig?{templateConfig:{...e.templateConfig,template:e.templateConfig.template,variables:e.templateConfig.variables,outputType:e.templateConfig.outputType,extractPattern:e.templateConfig.extractPattern,refusalWords:e.templateConfig.refusalWords,rejectRefusalWords:e.templateConfig.rejectRefusalWords}}:{},...e.type==="spreadsheet"&&e.spreadsheetConfig?{spreadsheetConfig:e.spreadsheetConfig}:{}},i=await this.generateApiCalls(s,e.repeatCount||1);return s.progress.total=i.length,s.progress.pending=i.length,await o.transaction("rw",o.trials,o.apiCalls,async()=>{await o.trials.add(s),i.length>0&&await o.apiCalls.bulkAdd(i)}),r.info(`V4_TRIALS: Created trial ${s.id} with ${i.length} API calls`),{ok:!0,value:s.id}}catch(t){return r.error("V4_TRIALS: Failed to create trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to create trial")}}}async updateTrial(e,t){try{return await o.transaction("rw",o.trials,async()=>{const a=await o.trials.get(e);if(!a)throw new Error(`Trial not found: ${e}`);const s={...a,...t,created:a.created};await o.trials.put(s)}),{ok:!0}}catch(a){return r.error("V4_TRIALS: Failed to update trial:",a),{ok:!1,error:a instanceof Error?a:new Error("Failed to update trial")}}}async deleteTrial(e){try{return await o.transaction("rw",o.trials,o.apiCalls,async()=>{const t=await o.trials.get(e);if(!t)throw new Error(`Trial not found: ${e}`);if(t.status==="running")throw new Error("Cannot delete running trial");await o.apiCalls.where("trialId").equals(e).delete(),await o.trials.delete(e)}),r.info(`V4_TRIALS: Deleted trial ${e} and all associated API calls`),{ok:!0}}catch(t){return r.error("V4_TRIALS: Failed to delete trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to delete trial")}}}async duplicateTrial(e){try{const t=await o.trials.get(e);if(!t)return{ok:!1,error:new Error(`Source trial not found: ${e}`)};const a={name:`${t.name} (Copy)`,description:t.description,type:t.type,configurations:t.configurations.map(s=>{var i;return{provider:s.provider,modelId:s.modelId,parameters:s.parameters,name:(i=s.modelSnapshot)==null?void 0:i.displayName}}),repeatCount:t.repeatCount,...t.type==="template"&&t.templateConfig?{templateConfig:t.templateConfig}:{},...t.type==="spreadsheet"&&t.spreadsheetConfig?{spreadsheetConfig:t.spreadsheetConfig}:{}};return this.createTrial(a)}catch(t){return r.error("V4_TRIALS: Failed to duplicate trial:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to duplicate trial")}}}async updateTrialProgress(e){try{return await o.transaction("rw",o.trials,o.apiCalls,async()=>{var d;const t=await o.trials.get(e);if(!t)throw new Error(`Trial not found: ${e}`);const a=await o.apiCalls.where("trialId").equals(e).toArray();let s=0,i=0,n=0,m=0,h=0;for(const T of a)switch(T.status){case"completed":s++;break;case"failed":i++,((d=T.result)==null?void 0:d.errorType)==="network_error_no_response"&&h++;break;case"cancelled":n++;break;case"running":m++;break}const f=t.progress.total-s-i-n-m;t.progress={total:t.progress.total,completed:s,failed:i,cancelled:n,pending:f,running:m,networkErrors:h},s+i+n>=t.progress.total&&t.status==="running"&&(t.status="completed",t.completed=new Date),await o.trials.put(t)}),{ok:!0}}catch(t){return r.error("V4_TRIALS: Failed to update trial progress:",t),{ok:!1,error:t instanceof Error?t:new Error("Failed to update progress")}}}async generateApiCalls(e,t){return r.info(`V4_TRIALS: Generating REAL API calls for trial ${e.id}, type: ${e.type}`),e.type==="template"&&e.templateConfig?this.generateTemplateApiCalls(e,e.templateConfig,t):e.type==="spreadsheet"&&e.spreadsheetConfig?this.generateSpreadsheetApiCalls(e,e.spreadsheetConfig,t):e.type==="playground"?[]:(r.warn(`V4_TRIALS: Unknown trial type or missing config for trial ${e.id}`),[])}async generateTemplateApiCalls(e,t,a){if(!t)return[];const s=[];let i=0;const n=await this.generateVariableCombinations(t.variables);r.info(`V4_TRIALS: Generated ${n.length} variable combinations`);for(let m=0;m<a;m++)for(let h=0;h<e.configurations.length;h++)for(const f of n){const d=this.substituteVariables(t.template,f.variables),T={id:$("call"),trialId:e.id,configurationIndex:h,order:i++,variables:f.variables,variableAttributes:f.variableAttributes,prompt:d,status:"pending",retryCount:0,created:new Date};s.push(T)}return r.info(`V4_TRIALS: Generated ${s.length} REAL API calls for template trial`),s}async generateSpreadsheetApiCalls(e,t,a){var m;if(!t)return[];const s=[];let i=0;const n=await o.variableLists.get(t.datasetId);if(!n||n.category!=="tabular"||!((m=n.tabularData)!=null&&m.rows))return r.warn(`V4_TRIALS: Dataset ${t.datasetId} not found or invalid`),[];for(let h=0;h<a;h++)for(const f of n.tabularData.rows){const d=this.substituteVariables(t.promptPattern,f);for(let T=0;T<e.configurations.length;T++){const p={id:$("call"),trialId:e.id,configurationIndex:T,order:i++,variables:f,prompt:d,status:"pending",retryCount:0,created:new Date};s.push(p)}}return r.info(`V4_TRIALS: Generated ${s.length} REAL API calls for spreadsheet trial`),s}async generateVariableCombinations(e){var m;const t=Object.keys(e).sort();if(t.length===0)return[{variables:{}}];const a={};for(const h of t){const f=e[h];let d=[];if(f.type==="value"&&f.values)d=f.values.map(T=>({value:T}));else if(f.type==="list"&&f.listId){const T=await o.variableLists.get(f.listId);T&&(T.category==="simple"&&T.values?d=T.values.map(p=>({value:p})):T.category==="attributed"&&T.items?d=T.items.map(p=>({value:p.value||p.name||String(p),attributes:p.attributes||{}})):T.category==="tabular"&&((m=T.tabularData)!=null&&m.rows)&&(d=T.tabularData.rows.map(p=>({value:p.name||p[Object.keys(p)[0]]||String(p)}))))}a[h]=d}const i=t.map(h=>Math.max(a[h].length,1)).reduce((h,f)=>h*f,1),n=[];for(let h=0;h<i;h++){const f={},d={};let T=h;for(let _=t.length-1;_>=0;_--){const R=t[_],E=a[R];if(E.length>0){const c=T%E.length,u=E[c];f[R]=u.value,u.attributes&&Object.keys(u.attributes).length>0&&(d[R]={...u.attributes}),T=Math.floor(T/E.length)}else f[R]=""}const p={variables:f};Object.keys(d).length>0&&(p.variableAttributes=d),n.push(p)}return n}substituteVariables(e,t){let a=e;for(const[s,i]of Object.entries(t)){const n=new RegExp(`\\{\\{\\s*${s}\\s*\\}\\}`,"g");a=a.replace(n,i)}return a}validateTrialConfig(e){var t;if(!e.name||e.name.trim().length===0)return{ok:!1,error:new Error("Trial name is required")};if(!e.configurations||e.configurations.length===0)return{ok:!1,error:new Error("At least one model configuration is required")};for(const a of e.configurations){if(!k.getProvider(a.provider))return{ok:!1,error:new Error(`Provider not found: ${a.provider}`)};const i=k.validateParameters(a.provider,a.modelId,a.parameters);if(!i.valid)return{ok:!1,error:new Error(`Invalid parameters: ${((t=i.errors)==null?void 0:t.join(", "))||"Validation failed"}`)}}if(e.type==="template"){if(!e.templateConfig||!e.templateConfig.template)return{ok:!1,error:new Error("Template is required for template trials")}}else if(e.type==="spreadsheet"&&(!e.spreadsheetConfig||!e.spreadsheetConfig.promptPattern))return{ok:!1,error:new Error("Prompt pattern is required for spreadsheet trials")};return{ok:!0}}async createConfigurationSnapshots(e){const t=[];for(const a of e){const s=k.getProvider(a.provider);if(!s)throw new Error(`Provider not found: ${a.provider}`);const n=(await o.models.where("provider").equals(a.provider).toArray()).find(h=>h.modelId===a.modelId),m={provider:a.provider,modelId:a.modelId,parameters:a.parameters,providerSnapshot:s,modelSnapshot:n||{id:`${a.provider}:${a.modelId}`,provider:a.provider,modelId:a.modelId,displayName:a.name||a.modelId,enabled:!0,source:"user"}};t.push(m)}return t}}const V=new Ie;function we(){const l=N(!1),e=N(!1),t=N(!1),a=N(!1),s=N(null),i=async c=>{l.value=!0,s.value=null;try{r.info("V4_TRIAL_COMMANDS: Creating trial with config:",c);const u=await V.createTrial(c);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial created successfully:",u.value):(s.value=u.error||new Error("Failed to create trial"),r.error("V4_TRIAL_COMMANDS: Create trial failed:",u.error)),u}finally{l.value=!1}},n=async(c,u,C)=>{try{const I=await o.template_prompts.get(c);if(!I)return{ok:!1,error:new Error(`Template not found: ${c}`)};const A={name:C||`${I.name} - ${new Date().toLocaleString()}`,description:I.description,type:"template",configurations:u,repeatCount:1,templateConfig:{template:I.template,variables:I.variables||{},outputType:I.outputType,extractPattern:I.extractPattern,refusalWords:I.refusalWords?[...I.refusalWords]:void 0,rejectRefusalWords:I.rejectRefusalWords}};return i(A)}catch(I){return r.error("V4_TRIAL_COMMANDS: Failed to create trial from template:",I),{ok:!1,error:I instanceof Error?I:new Error("Failed to create trial from template")}}},m=async(c,u,C,I)=>{try{const A=await o.variableLists.get(u);if(!A||A.category!=="tabular")return{ok:!1,error:new Error(`Dataset not found or not tabular: ${u}`)};const y={name:I||`Spreadsheet Trial - ${new Date().toLocaleString()}`,type:"spreadsheet",configurations:C,spreadsheetConfig:{promptPattern:c,datasetId:u}};return i(y)}catch(A){return r.error("V4_TRIAL_COMMANDS: Failed to create spreadsheet trial:",A),{ok:!1,error:A instanceof Error?A:new Error("Failed to create spreadsheet trial")}}},h=async(c,u)=>{e.value=!0,s.value=null;try{const C=await V.updateTrial(c,u);return C.ok||(s.value=C.error||new Error("Failed to update trial"),r.error("V4_TRIAL_COMMANDS: Update trial failed:",C.error)),C}finally{e.value=!1}},f=async(c,u)=>h(c,{status:u}),d=async c=>{t.value=!0,s.value=null;try{r.info("V4_TRIAL_COMMANDS: Deleting trial:",c);const u=await V.deleteTrial(c);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial deleted successfully"):(s.value=u.error||new Error("Failed to delete trial"),r.error("V4_TRIAL_COMMANDS: Delete trial failed:",u.error)),u}finally{t.value=!1}},T=async c=>{t.value=!0,s.value=null;try{return r.info("V4_TRIAL_COMMANDS: Deleting multiple trials:",c.length),await o.transaction("rw",o.trials,o.apiCalls,async()=>{for(const u of c){const C=await o.trials.get(u);C&&C.status!=="running"&&(await o.apiCalls.where("trialId").equals(u).delete(),await o.trials.delete(u))}}),r.info("V4_TRIAL_COMMANDS: Multiple trials deleted successfully"),{ok:!0}}catch(u){return r.error("V4_TRIAL_COMMANDS: Failed to delete multiple trials:",u),s.value=u instanceof Error?u:new Error("Failed to delete trials"),{ok:!1,error:s.value}}finally{t.value=!1}},p=async c=>{a.value=!0,s.value=null;try{r.info("V4_TRIAL_COMMANDS: Duplicating trial:",c);const u=await V.duplicateTrial(c);return u.ok?r.info("V4_TRIAL_COMMANDS: Trial duplicated successfully:",u.value):(s.value=u.error||new Error("Failed to duplicate trial"),r.error("V4_TRIAL_COMMANDS: Duplicate trial failed:",u.error)),u}finally{a.value=!1}},_=async c=>{var u,C;try{let I=1;if(c.type==="template"&&c.templateConfig){const y=c.templateConfig.variables;for(const[,S]of Object.entries(y))if(S.type==="value"&&S.values)I*=S.values.length;else if(S.type==="list"&&S.listId){const b=await o.variableLists.get(S.listId);b&&(b.category==="simple"&&b.values?I*=b.values.length:b.category==="attributed"&&b.items?I*=b.items.length:b.category==="tabular"&&((u=b.tabularData)!=null&&u.rows)&&(I*=b.tabularData.rows.length))}}else if(c.type==="spreadsheet"&&c.spreadsheetConfig){const y=await o.variableLists.get(c.spreadsheetConfig.datasetId);y&&y.category==="tabular"&&((C=y.tabularData)!=null&&C.rows)&&(I=y.tabularData.rows.length)}return I*c.configurations.length*(c.repeatCount||1)}catch(I){return r.error("V4_TRIAL_COMMANDS: Failed to calculate API call count:",I),0}};return{createTrial:i,createTrialFromTemplate:n,createTrialFromSpreadsheet:m,updateTrial:h,updateTrialStatus:f,deleteTrial:d,deleteMultipleTrials:T,duplicateTrial:p,generateApiCallCount:_,estimateTrialCost:async c=>{var u,C;try{const I=await _(c);let A=0;for(const y of c.configurations){const b=(await o.models.where("provider").equals(y.provider).toArray()).find(P=>P.modelId===y.modelId);if(b!=null&&b.capabilities){const K=((u=y.parameters)==null?void 0:u.max_tokens)||((C=y.parameters)==null?void 0:C.maxTokens)||256,ee=(b.capabilities.inputCostPerToken||0)*150,te=(b.capabilities.outputCostPerToken||0)*K;A+=(ee+te)*I/c.configurations.length}}return A}catch(I){return r.error("V4_TRIAL_COMMANDS: Failed to estimate cost:",I),0}},validateTrialConfig:c=>!c.name||c.name.trim().length===0?{ok:!1,error:new Error("Trial name is required")}:!c.configurations||c.configurations.length===0?{ok:!1,error:new Error("At least one model configuration is required")}:c.type==="template"&&!c.templateConfig?{ok:!1,error:new Error("Template configuration is required for template trials")}:c.type==="spreadsheet"&&!c.spreadsheetConfig?{ok:!1,error:new Error("Spreadsheet configuration is required for spreadsheet trials")}:{ok:!0},isCreating:l,isUpdating:e,isDeleting:t,isDuplicating:a,lastError:s}}export{Y as C,Z as F,we as a,ye as b,be as c,Oe as u};
