var e=Object.defineProperty,t=(t,a,r)=>((t,a,r)=>a in t?e(t,a,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[a]=r)(t,"symbol"!=typeof a?a+"":a,r);import{S as a,f as r,c as n,U as i}from"./vendor-DImCB_rW.js";import{l as s}from"./db-CL8uhZCz.js";import{l as o,X as l,d as c,W as u}from"./index-Dynr8V5n.js";import"./defaultData-BR5V2V3r.js";import{v as d}from"./variable.service-DGu7U4d3.js";const g=new class{extractVariables(e){const t=[...e.matchAll(/\{\{(\w+)\}\}/g)];return[...new Set(t.map(e=>e[1]))]}validateTemplate(e){const t=[];if(!e.trim())return{isValid:!1,errors:["Template cannot be empty"],variables:[]};(e.match(/\{\{/g)||[]).length!==(e.match(/\}\}/g)||[]).length&&t.push("Mismatched braces - ensure all {{variables}} are properly closed");/\{\{[^}]*\{\{/.test(e)&&t.push("Nested braces are not allowed");/\{\{\s*\}\}/.test(e)&&t.push("Empty variable placeholders are not allowed");const a=e.match(/\{\{([^}]*)\}\}/g)?.filter(e=>{const t=e.slice(2,-2).trim();return!/^\w+$/.test(t)});a&&a.length>0&&t.push("Variable names must contain only letters, numbers, and underscores");const r=this.extractVariables(e);return{isValid:0===t.length,errors:t,variables:r}}createTestPrompt(e,t,a=0){let r=e;for(const[n,i]of Object.entries(t))if(i&&i.length>0){const e=i[a%i.length]||i[0];r=r.replace(new RegExp(`\\{\\{${n}\\}\\}`,"g"),e)}return r}renderTemplate(e,t){let a=e;for(const[r,n]of Object.entries(t))a=a.replace(new RegExp(`\\{\\{${r}\\}\\}`,"g"),n);return a}getMissingVariables(e,t){return this.extractVariables(e).filter(e=>!t[e]||0===t[e]?.length)}},p=class e{calculateTotalPermutations(e){const t=Object.values(e).filter(e=>e>0);return 0===t.length?0:t.reduce((e,t)=>e*t,1)}getPermutationInfo(t){const a=this.calculateTotalPermutations(t);let r,n;return r=a>999999?`${(a/1e6).toFixed(1)}M`:a>9999?`${(a/1e3).toFixed(0)}k`:a.toLocaleString(),a>e.VERY_LARGE_THRESHOLD?n="Very large trial - may take hours and significant API costs":a>e.LARGE_THRESHOLD&&(n="Large trial - consider sampling or filtering"),{total:a,isLarge:a>e.LARGE_THRESHOLD,formatted:r,warning:n}}*generatePermutations(e,t=1/0){const a=Object.keys(e),r=a.map(t=>e[t]);if(0===a.length)return;let n=0;const i=function*(e,s){if(n>=t)return;if(e===a.length)return yield{...s},void n++;const o=a[e],l=r[e];for(const a of l){if(n>=t)return;s[o]=a,yield*i(e+1,s)}};yield*i(0,{})}getSamplePermutations(e,t=5){const a=[],r=this.generatePermutations(e,t);for(const n of r)a.push(n);return a}estimateTrialMetrics(e,t,a=2e3,r=.01){const n=e*t,i=n*a*.7;return{totalCalls:n,estimatedTimeMinutes:Math.ceil(i/6e4),estimatedCostUSD:n*r}}shouldSample(t,a=e.LARGE_THRESHOLD){const r=this.calculateTotalPermutations(t);if(r<=a)return{shouldSample:!1};let n;return n=r>1e6?1e3:r>1e5?5e3:Math.min(1e4,Math.floor(.1*r)),{shouldSample:!0,recommendedSampleSize:n}}*generateStratifiedSample(e,t){const a=this.calculateTotalPermutations(Object.fromEntries(Object.entries(e).map(([e,t])=>[e,t.length])));if(a<=t)return void(yield*this.generatePermutations(e));const r=Math.floor(a/t);let n=0,i=0;for(const s of this.generatePermutations(e))if(n%r===0&&i<t&&(yield s,i++),n++,i>=t)break}};t(p,"LARGE_THRESHOLD",1e4),t(p,"VERY_LARGE_THRESHOLD",1e5);const m=new p;function h(e){return new Worker(""+new URL("token-calculation.worker-Bs6FCesY.js",import.meta.url).href,{name:e?.name})}const f=new class{constructor(){t(this,"worker",null),t(this,"pendingRequests",new Map),t(this,"isWorkerSupported","undefined"!=typeof Worker),t(this,"workerLoadError",null),this.isWorkerSupported&&this.initializeWorker()}initializeWorker(){try{this.worker=new h,this.worker.addEventListener("message",this.handleWorkerMessage.bind(this)),this.worker.addEventListener("error",this.handleWorkerError.bind(this))}catch(e){o.error("Failed to initialize token calculation worker",e),this.workerLoadError=e,this.isWorkerSupported=!1}}handleWorkerMessage(e){const t=e.data,a=this.pendingRequests.get(t.id);if(a)switch(t.type){case"progress":a.onProgress?.(t);break;case"result":a.resolve(t.result),this.pendingRequests.delete(t.id);break;case"error":a.reject(new Error(t.error.message)),this.pendingRequests.delete(t.id)}else o.warn("Received message for unknown request",{messageId:t.id})}handleWorkerError(e){o.error("Worker error",e),this.pendingRequests.forEach(e=>{e.reject(new Error("Worker crashed"))}),this.pendingRequests.clear(),this.worker?.terminate(),this.worker=null,setTimeout(()=>{this.isWorkerSupported&&this.initializeWorker()},1e3)}async prepareDesignData(e){const t=JSON.parse(JSON.stringify(e)),a={};for(const[n,i]of Object.entries(t.variableBindings||{}))if("list"===i.type&&i.listId)try{const e=await d.getListValues(i.listId);a[n]={type:"direct",values:[...e]}}catch(r){o.warn("Failed to resolve list values for variable",{error:r,varName:n}),a[n]={type:"direct",values:[]}}else a[n]=JSON.parse(JSON.stringify(i));return{id:t.id,promptTemplate:t.promptTemplate,variableBindings:a}}async calculateApproximate(e){if(!this.isWorkerSupported||!this.worker)return this.calculateApproximateMainThread(e);const t=`${e.id}-${Date.now()}-${Math.random()}`,a=await this.prepareDesignData(e);return new Promise((e,r)=>{this.pendingRequests.set(t,{resolve:e,reject:r});const n={id:t,method:"approximate",design:a};this.worker.postMessage(n),setTimeout(()=>{this.pendingRequests.has(t)&&(this.pendingRequests.delete(t),r(new Error("Worker timeout")))},5e3)})}async calculateAccurate(e,t){if(!this.isWorkerSupported||!this.worker)return o.warn("Worker not available, falling back to approximate calculation"),this.calculateApproximateMainThread(e);const a=`${e.id}-${Date.now()}-${Math.random()}`,r=await this.prepareDesignData(e);return new Promise((e,n)=>{this.pendingRequests.set(a,{resolve:e,reject:n,onProgress:t});const i={id:a,method:"accurate",design:r};this.worker.postMessage(i),setTimeout(()=>{this.pendingRequests.has(a)&&(this.pendingRequests.delete(a),n(new Error("Worker timeout - calculation taking too long")))},6e4)})}async calculateApproximateMainThread(e){const t=e=>Math.ceil(e.length/4),a=e.promptTemplate.replace(/\{\{[^}]+\}\}/g,""),r=t(a),n={};for(const[c,u]of Object.entries(e.variableBindings||{}))if("direct"===u.type&&u.values)n[c]=u.values;else if("list"===u.type&&u.listId)try{n[c]=await d.getListValues(u.listId)}catch{n[c]=[]}const i={};for(const[c,u]of Object.entries(n)){if(0===u.length){i[c]={min:0,max:0,avg:0};continue}const e=u.map(e=>t(e));i[c]={min:Math.min(...e),max:Math.max(...e),avg:Math.round(e.reduce((e,t)=>e+t,0)/e.length)}}let s=r,o=r,l=r;for(const c of Object.values(i))s+=c.min,o+=c.max,l+=c.avg;return{minTokens:s,maxTokens:o,avgTokens:l,sampleSize:Object.values(n).reduce((e,t)=>e+t.length,0),calculated:new Date,isAccurate:!1}}isWorkerAvailable(){return this.isWorkerSupported&&null!==this.worker&&null===this.workerLoadError}terminate(){this.worker&&(this.pendingRequests.forEach(e=>{e.reject(new Error("Worker terminated"))}),this.pendingRequests.clear(),this.worker.terminate(),this.worker=null)}};const k=new class{constructor(){t(this,"tokenCountCache",new Map)}async calculateDesignTokens(e){try{const a=this.getDesignCacheKey(e),r=this.tokenCountCache.get(a);if(r&&r.calculated&&Date.now()-r.calculated.getTime()<36e5)return r;if(o.info("Calculating tokens for design",{designName:e.name}),f.isWorkerAvailable())try{const t=await f.calculateApproximate(e);return o.info("Token calculation complete (worker)",{designName:e.name}),this.tokenCountCache.set(a,t),t}catch(t){o.warn("Worker calculation failed, falling back to main thread",{error:t})}o.info("Calculating tokens on main thread");const n=e.promptTemplate.replace(/\{\{[^}]+\}\}/g,""),i=await this.countTokens(n),s=await this.getVariableValues(e),l={};for(const[e,t]of Object.entries(s)){if(0===t.length){l[e]={min:0,max:0,avg:0};continue}const a=await Promise.all(t.map(e=>this.countTokens(e)));l[e]={min:Math.min(...a),max:Math.max(...a),avg:Math.round(a.reduce((e,t)=>e+t,0)/a.length)}}let c=i,u=i,d=i;for(const e of Object.values(l))c+=e.min,u+=e.max,d+=e.avg;const g={minTokens:c,maxTokens:u,avgTokens:d,sampleSize:Object.values(s).reduce((e,t)=>e+t.length,0),calculated:new Date,isAccurate:!1};return o.info("Token calculation complete (main thread)",{designName:e.name}),this.tokenCountCache.set(a,g),g}catch(a){return o.error("Failed to calculate design tokens",a),{minTokens:0,maxTokens:0,avgTokens:0,sampleSize:0,calculated:new Date}}}async calculateDesignTokensAccurate(e,t){try{const r=this.getDesignCacheKey(e)+":accurate",n=this.tokenCountCache.get(r);if(n&&n.calculated&&n.isAccurate&&Date.now()-n.calculated.getTime()<36e5)return n;if(f.isWorkerAvailable())try{const a=await f.calculateAccurate(e,t?e=>{t({stage:e.stage,current:e.current,total:e.total,message:e.message})}:void 0);return o.info("Accurate token calculation complete (worker)",{designName:e.name}),this.tokenCountCache.set(r,a),a}catch(a){return o.warn("Worker accurate calculation failed, falling back to approximate",{error:a}),this.calculateDesignTokens(e)}o.warn("Worker not available for accurate calculation, using approximate");return{...await this.calculateDesignTokens(e),isAccurate:!0}}catch(r){return o.error("Failed to calculate accurate tokens",r),this.calculateDesignTokens(e)}}async calculateCostEstimate(e,t,a){const r=await this.calculateDesignTokens(e),n=this.getOutputTokenLimit(t.provider,t.modelId,a),i=t.capabilities?.inputCostPerToken||0,s=t.capabilities?.outputCostPerToken||0,o={min:r.minTokens*i+n*s,max:r.maxTokens*i+n*s,avg:r.avgTokens*i+n*s},l=await this.getVariableCounts(e),c=m.calculateTotalPermutations(l);return{inputTokens:r,outputTokens:n,costPerCall:o,totalCost:{min:o.min*c,max:o.max*c,avg:o.avg*c},environmentalCosts:undefined}}getOutputTokenLimit(e,t,a){return l.getOutputTokenLimit(e,t,a)}async countTokens(e){return e&&0!==e.length?Math.ceil(e.length/4):0}async getVariableCounts(e){const t={};for(const[a,r]of Object.entries(e.variableBindings||{}))if("direct"===r.type&&r.values)t[a]=r.values.length;else if("list"===r.type&&r.listId){const e=await d.getListValues(r.listId);t[a]=e.length}return t}async getVariableValues(e){const t={};try{for(const[r,n]of Object.entries(e.variableBindings||{}))if("direct"===n.type&&n.values)t[r]=n.values;else if("list"===n.type&&n.listId)try{const e=await d.getListValues(n.listId);t[r]=e}catch(a){o.warn("Failed to get list values for variable",{error:a,varName:r}),t[r]=[]}}catch(a){o.error("Error getting variable values",a)}return t}getDesignCacheKey(e){const t=JSON.stringify(e.variableBindings);return`${e.id}:${e.promptTemplate}:${t}`}async calculateEnvironmentalCostEstimate(e,t,a){return{carbon:0,water:0,energy:0,confidence:"none",source:"no-data"}}clearCache(){this.tokenCountCache.clear()}},w=a("designs",()=>{const e=r([]),t=r(!1),a=r(null);let l=null;async function d(e){const t=new Date,a=u(),r=g.validateTemplate(e.promptTemplate);if(!r.isValid)throw new Error(`Invalid template: ${r.errors.join(", ")}`);let n;if(e.variableBindings&&Object.keys(e.variableBindings).length>0)try{const r={...e,id:a,created:t,updated:t,outputType:e.outputType||"text"};n=await k.calculateDesignTokens(r)}catch(s){o.warn("Failed to calculate token estimate:",{error:s})}const i={...e,id:a,created:t,updated:t,tokenEstimate:n,outputType:e.outputType||"text"};try{return await c.designs.add(i),a}catch(s){throw o.error("Failed to create design",s),new Error("Failed to create design")}}async function p(e){try{const t=await c.designs.get(e);return o.debug("getDesign retrieved",{id:e,found:!!t}),t}catch(t){return void o.error("Failed to get design",t)}}const m=n(()=>e.value.map(e=>{const t=g.extractVariables(e.promptTemplate),a=Object.values(e.variableBindings||{}).some(e=>"list"===e.type);return{...e,variableCount:t.length,hasExtraction:!!e.extractPattern,hasListRefs:a}})),h=n(()=>e.value.slice().sort((e,t)=>t.updated.getTime()-e.updated.getTime())),f=n(()=>h.value.slice(0,5));return{designs:i(e),isLoading:i(t),error:i(a),designsWithStats:m,designsByDate:h,recentDesigns:f,initialize:async function(){if(!l){t.value=!0,a.value=null;try{l=s(()=>c.designs.orderBy("updated").reverse().toArray()).subscribe({next:async a=>{e.value=a,t.value=!1,a.length>0&&setTimeout(()=>{!async function(e){const t=e.filter(e=>!e.tokenEstimate&&e.variableBindings&&Object.keys(e.variableBindings).length>0);if(0===t.length)return;o.debug(`Starting background token calculation for ${t.length} designs`);const a=t.map(async e=>{try{const t=await k.calculateDesignTokens(e);await c.designs.update(e.id,{tokenEstimate:t}),o.debug(`Background token calculation complete for: ${e.name}`)}catch(t){o.warn(`Background token calculation failed for ${e.name}:`,{error:t})}});Promise.all(a).then(()=>{o.debug("All background token calculations complete")})}(a)},500)},error:e=>{o.error("Designs store subscription error",e),a.value="Failed to load designs",t.value=!1}})}catch(r){o.error("Failed to initialize designs store",r),a.value="Failed to initialize designs",t.value=!1}}},createDesign:d,updateDesign:async function(e,t){try{if(void 0!==t.promptTemplate){const e=g.validateTemplate(t.promptTemplate);if(!e.isValid)throw new Error(`Invalid template: ${e.errors.join(", ")}`)}const r=await c.designs.get(e);if(!r)throw new Error("Design not found");let n=r.tokenEstimate;if(void 0!==t.promptTemplate||void 0!==t.variableBindings){const e={...r,...t,updated:new Date};if(e.variableBindings&&Object.keys(e.variableBindings).length>0)try{const t={id:r.id,name:e.name,promptTemplate:e.promptTemplate,variableBindings:e.variableBindings,outputType:e.outputType,created:r.created,updated:e.updated,description:e.description,extractPattern:e.extractPattern,refusalWords:e.refusalWords,refusalWordsListRef:e.refusalWordsListRef,refusalWordsSource:e.refusalWordsSource,rejectRefusalWords:e.rejectRefusalWords};n=await k.calculateDesignTokens(t)}catch(a){o.warn("Failed to calculate token estimate:",{error:a})}else n=void 0}o.debug("updateDesign called",{id:e,changes:t}),await c.designs.update(e,{...t,tokenEstimate:n,updated:new Date}),o.debug("Design updated successfully",{id:e})}catch(a){throw o.error("Failed to update design",a),new Error("Failed to update design")}},deleteDesign:async function(e){try{if(await c.trials.where("designId").equals(e).count()>0)throw new Error("Cannot delete design - it is used in existing trials");await c.designs.delete(e)}catch(t){if(o.error("Failed to delete design",t),t instanceof Error)throw t;throw new Error("Failed to delete design")}},getDesign:p,getAllDesigns:async function(){try{return await c.designs.toArray()}catch(e){return o.error("Failed to get all designs",e),[]}},duplicateDesign:async function(t,a){const r=await p(t);if(!r)throw new Error("Design not found");const n=a||`${r.name} (copy)`;let i=n,s=1;for(;e.value.some(e=>e.name===i);)i=`${n} ${s}`,s++;return d({name:i,description:r.description,promptTemplate:r.promptTemplate,variableBindings:r.variableBindings,outputType:r.outputType,extractPattern:r.extractPattern,refusalWords:r.refusalWords,rejectRefusalWords:r.rejectRefusalWords})},searchDesigns:t=>{if(!t.trim())return e.value;const a=t.toLowerCase().trim();return e.value.filter(e=>{if(e.name.toLowerCase().includes(a)||e.description?.toLowerCase().includes(a))return!0;return g.extractVariables(e.promptTemplate).some(e=>e.toLowerCase().includes(a))})},destroy:function(){l&&(l.unsubscribe(),l=null)}}});export{k as a,m as p,g as t,w as u};
